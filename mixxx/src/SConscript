#EXAMPLES of random stuff that might be useful later in Mixxx's SConstruct file
#==============================================================================
"""
#Example: Checking for a C header
if not conf.CheckCHeader('math.h'):
    print 'Math.h must be installed!'
    Exit(1)
if conf.CheckCHeader('foo.h'):
    conf.env.Append('-DHAS_FOO_H')
"""

"""
#Example: Checking for a C++ header
if not conf.CheckCXXHeader('vector.h'):
    print 'vector.h must be installed!'
    Exit(1)
"""

"""
#Example: Checking for a library
if not conf.CheckLib('m'):
    print 'Did not find libm.a or m.lib, exiting!'
    Exit(1)
"""

"""
#Example: Checking for a library AND a header (probably what we want to do)
if not conf.CheckLibWithHeader('m', 'math.h'):
    print 'Did not find libm.a or m.lib, exiting!'
    Exit(1)
"""

import os
import sys
import glob
import SCons

# BIG FAT WARNING:
# Make sure you use TABS for indentation, NOT spaces! (Python doesn't like spaces, be forewarned!)
#
#   ####       ####  ##########  #####    #####  #####    #####  #####    #####
#   ######   ######     ####      #####  #####    #####  #####    #####  #####
#   #### ## ## ####     ####        ########        ########        ########
#   ####   #   ####     ####      #####  #####    #####  #####    #####  #####
#   ####       ####  ##########  #####    #####  #####    #####  #####    #####
#
#  #############################################################################
#    #########################################################################
#
#Start of Mixxx's real SConstruct file
#=======================================

#Checks for OpenGL on all three platforms
def CheckOpenGL():
	if not conf.CheckLib('GL') and not conf.CheckLib('opengl32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/gl.h'):
		print 'Did not find OpenGL development files, exiting!'
		Exit(1)

	if not conf.CheckLib('GLU') and not conf.CheckLib('glu32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/glu.h'):
		print 'Did not find GLU development files, exiting!'
		Exit(1)
	#Workaround for SCONS not detecting frameworks on OS X
	if platform == 'osx':
		env.Append(LINKFLAGS = '-framework OpenGL')

	return

#Checks for OpenGL on all three platforms
def CheckOggVorbis():
	#Check for Ogg and Vorbis on Linux and Win32
	if platform == 'linux' or platform == 'win32':
		if not conf.CheckLib('vorbisfile'):
			print 'Did not find libvorbisfile.a, libvorbisfile.lib, or the libvorbisfile development headers, exiting!'
			Exit(1)

		if not conf.CheckLib('ogg'):
			print 'Did not find libogg.a, libogg.lib, or the libogg development headers, exiting!'
			Exit(1)

	elif platform == 'osx':
		#Check for Ogg and Vorbis on OS X
		if not conf.CheckCHeader('/Library/Frameworks/Vorbis.framework/Versions/A/Headers/vorbisfile.h'):
			print 'Did not find Vorbis framework, exiting! (Please install it)'
			Exit(1)
		else:
			env.Append(LINKFLAGS = '-framework Vorbis')

		#Check for Ogg
		if not conf.CheckCHeader('/Library/Frameworks/Ogg.framework/Versions/A/Headers/ogg.h'):
			print 'Did not find Ogg framework, exiting! (Please install it)'
			Exit(1)
		else:
			env.Append(LINKFLAGS = '-framework Ogg')

	return

def flatten(x):
	"""flatten(sequence) -> list

	Returns a single, flat list which contains all elements retrieved
	from the sequence and all recursively contained sub-sequences
    (iterables).

    Examples:
    >>> [1, 2, [3,4], (5,6)]
    [1, 2, [3, 4], (5, 6)]
    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, MyVector(8,9,10)])
    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]"""

	result = []
	for el in x:
		#if isinstance(el, (list, tuple)):
		if hasattr(el, "__iter__"):
			result.extend(flatten(el))
		else:
			result.append(el)
	return result

###### MAIN LINE ######
#######################
#Get the platform/OS that we're building on:
if os.name == 'nt':
	print 'Platform: Windows'
	platform = 'win32'
elif sys.platform == 'linux2':
	print 'Platform: Linux'
	platform = 'linux'
elif sys.platform == 'darwin':
	print 'Platform: OS X'
	platform = 'osx'
else:
	print 'Platform: Unknown (assuming Linux-like)'
	platform = 'linux'


#Figure out what the QT path is
if platform == 'linux' or platform == 'osx':
	default_qtdir = '/usr/share/qt4'
elif platform == 'win32':
	default_qtdir = 'C:\\qt\\4.3.0'

#Read the qtdir flag, if it was set explicitly
flags_qtdir = ARGUMENTS.get('qtdir', default_qtdir)
if not os.path.exists(flags_qtdir):
	print "Error: QT path does not exist or QT4 is not installed."
	print "Please specify your QT path by running 'scons qtdir=[path]'"
	Exit(1)
elif flags_qtdir.find("qt3") != -1:
	print "Error: Mixxx now requires QT4 instead of QT3 - please use your QT4 path instead."
	Exit(1)
else:
	print "QT path: " + flags_qtdir

#Set up our environment, tell SCONS to use it's QT tools, and set some enviroment variables for it.
# qt4ToolLocation='.'
if platform == 'linux' or platform == 'osx':
	env = Environment(tools=['default','qt4', 'msvs'], toolpath=['../', './'], QTDIR=flags_qtdir, QT_LIB='')
elif platform == 'win32':
	#Pull in the environment's variables for win32...
	env = Environment(tools=['default','qt4', 'msvs'], toolpath=['../', './'], QTDIR=flags_qtdir, QT_LIB='', VCINSTALLDIR = os.getenv('VCInstallDir'), ENV = os.environ)

#env.Append(CPPPATH='.')

#Mixxx sources to build
sources = Split("""enginebuffercue.cpp input.cpp mixxxmenuplaylists.cpp trackplaylistlist.cpp mixxxkeyboard.cpp configobject.cpp controlobjectthread.cpp
 controlobjectthreadwidget.cpp controlobjectthreadmain.cpp controlevent.cpp controllogpotmeter.cpp controlobject.cpp controlnull.cpp controlpotmeter.cpp
 controlpushbutton.cpp controlttrotary.cpp controlbeat.cpp dlgpreferences.cpp dlgprefsound.cpp dlgprefmidi.cpp dlgprefplaylist.cpp dlgprefcontrols.cpp
 dlgprefmixer.cpp enginebuffer.cpp enginebufferscale.cpp enginebufferscalelinear.cpp engineclipping.cpp enginefilterblock.cpp enginefilteriir.cpp  enginefilter.cpp engineobject.cpp
 enginepregain.cpp enginevolume.cpp main.cpp midiobject.cpp midiobjectnull.cpp mixxx.cpp mixxxview.cpp 
 soundsourcemp3.cpp soundsourceoggvorbis.cpp enginechannel.cpp enginemaster.cpp wwidget.cpp wpixmapstore.cpp wlabel.cpp wnumber.cpp
 wnumberpos.cpp wnumberrate.cpp wnumberbpm.cpp wknob.cpp wdisplay.cpp wvumeter.cpp wpushbutton.cpp wslidercomposed.cpp wslider.cpp wtracktable.cpp
 wtracktableitem.cpp wstatuslight.cpp enginedelay.cpp engineflanger.cpp enginespectralfwd.cpp mathstuff.cpp readerextract.cpp readerextractwave.cpp
 readerevent.cpp rtthread.cpp windowkaiser.cpp probabilityvector.cpp reader.cpp enginevumeter.cpp peaklist.cpp rotary.cpp log.cpp
 track.cpp trackcollection.cpp trackplaylist.cpp wtracktableview.cpp wtracktablemodel.cpp proxymodel.cpp xmlparse.cpp wtreeview.cpp wtreeitem.cpp wtreeitemfile.cpp wtreeitemdir.cpp wtreeitemplaylist.cpp
 wtreeitemplaylistroot.cpp trackimporter.cpp parser.cpp parserpls.cpp parserm3u.cpp
 enginetemporal.cpp visual/visualbuffertemporal.cpp wavesummary.cpp bpmdetector.cpp bpmdetect.cpp bpmscheme.cpp  peakfinder.cpp wavesegmentation.cpp soundsourceproxy.cpp woverview.cpp enginebeatseek.cpp
 enginebufferscalereal.cpp powermate.cpp  hercules.cpp joystick.cpp mouse.cpp
 wvisualsimple.cpp wvisualwaveform.cpp visual/visualbackplane.cpp visual/texture.cpp visual/visualbox.cpp visual/visualbuffer.cpp visual/visualbuffersignal.cpp
 visual/visualbuffersignalhfc.cpp visual/visualbuffermarks.cpp visual/visualchannel.cpp visual/visualcontroller.cpp visual/visualdisplay.cpp visual/visualdisplaybuffer.cpp
 visual/light.cpp visual/material.cpp visual/picking.cpp visual/pickable.cpp visual/visualobject.cpp
 imginvert.cpp imgloader.cpp imgcolor.cpp wskincolor.cpp
 trackinfoobject.cpp soundsource.cpp
 midiledhandler.cpp
 sounddevice.cpp soundmanager.cpp sounddeviceportaudio.cpp
 enginevinylsoundemu.cpp """)
# trackinfoobject.cpp soundsource.cpp

#Crap we don't want anymore:
#playerportaudio.cpp player.cpp playerproxy.cpp 

#Compile platform specific hardware support
if platform == 'linux':
	sources += Split("""powermatelinux.cpp herculeslinux.cpp joysticklinux.cpp mouselinux.cpp """)
#elif platform == 'win32':
#	sources += Split("""powermatewin.cpp mousewin.cpp """)

#Compile platform specific MIDI support
if platform == 'linux':
	sources += Split("""midiobjectalsaseq.cpp """)  #ALSA Sequencer MIDI support for Linux
	env.Append(CXXFLAGS = '-D__ALSASEQMIDI__')
elif platform == 'win32':
	sources += Split("""midiobjectwin.cpp """)      #Windows MIDI support
	env.Append(CXXFLAGS = '-D__WINMIDI__')
elif platform == 'osx':
	sources += Split("""midiobjectcoremidi.cpp """) #CoreMidi support for OS X
	env.Append(CXXFLAGS = '-D__COREMIDI__')


#Set up the library path on Windows:
if platform == 'win32':
	env.Append(CPPPATH='../../../mixxx-winlib') #If you add more directories, separate them with a semicolon (;)
	env.Append(LIBPATH='../../../mixxx-winlib')
	env.Append(LINKFLAGS = ['/nodefaultlib:libc.lib', '/nodefaultlib:libcd.lib'])
	env.Prepend(LINKFLAGS = ['/DEBUG','/PDB:dist/mixxx.pdb']) # Generate MS VC Program Debug Database

#Check for dependencies if we're not doing a clean...

if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
	conf = Configure(env)

# On Posix default SCons.LIBPREFIX = 'lib', on Windows default SCons.LIBPREFIX = ''

	if not conf.CheckLibWithHeader('portaudio', 'portaudio.h', 'C'):
		print 'Did not find libportaudio.a, portaudio.lib, or the PortAudio-v19 development header files - exiting!'
		Exit(1)

# 	if not conf.CheckLib(['$QTDIR/lib/qt-mt','$QTDIR/lib/qt-mt3']):
# 		print 'Did not find libqt-mt.a or libqt-mt.lib, exiting!'
# 		Exit(1)

	if not conf.CheckLib(['mad','libmad']):
		print 'Did not find libmad.a, libmad.lib, or the libmad development header files - exiting!'
		Exit(1)

	if not conf.CheckLib(['id3tag','libid3tag-release']):
		print 'Did not find libid3tag.a, libid3tag.lib, or the libid3tag development header files - exiting!'
		Exit(1)

	#Check for Ogg and Vorbis
	CheckOggVorbis()

	#Check for OpenGL (it's messy to do it for all three platforms)
	CheckOpenGL()

	#Platform-specific checks for Linux and Win32...
	if platform == 'linux' or platform == 'win32':
	    #Check for libsndfile
		#if not conf.CheckLibWithHeader(['sndfile', 'libsndfile'], 'sndfile.h', 'C'):
		if not conf.CheckLib(['sndfile', 'libsndfile']):
			print "Did not find libsndfile or it\'s development headers, exiting!"
			Exit(1)
		else:
			env.Append(CXXFLAGS = ' -D__SNDFILE__')
			sources.append('soundsourcesndfile.cpp') ## TODO: Convert this to a SharedLibrary, so it can be installed without having to run scons twice after a clean
			# libsndfile = env.SharedLibrary(
			# "libsndfile",
			# source=["soundsourcesndfile.cpp", "trackinfoobject.cpp"])

	#Platform-specific checks for Linux...
	if platform == 'linux':
		#Check for libdjconsole, if it was passed as a flag
		flags_djconsole = ARGUMENTS.get('djconsole', 0)
		if int(flags_djconsole):
			if not conf.CheckLibWithHeader('djconsole', 'libdjconsole/djconsole.h', 'C++'):
				print "Did not find libdjconsole or it\'s development headers, exiting!"
				Exit(1)
			env.ParseConfig('pkg-config libdjconsole --silence-errors --cflags --libs')
			env.Append(CXXFLAGS = '-D__LIBDJCONSOLE__')

		#Another check for PortAudio-v19
		env.ParseConfig('pkg-config --cflags --libs portaudio-2.0')
		#If the above line looks like magic, it's because it really is. (Read about ParseConfig, it's nifty)

	#Platform-specific checks for OS X
	if platform == 'osx':
	    #Check for libaudiofile
		if not conf.CheckLibWithHeader('audiofile', 'audiofile.h', 'C'):
			print "Did not find libaudiofile or it\'s development headers, exiting!"
			Exit(1)
		else:
			env.Append(CXXFLAGS = ' -D__AUDIOFILE__')
			sources.append('soundsourceaudiofile.cpp')

		#Check for CoreMIDI
		if not conf.CheckCHeader('/System/Library/Frameworks/CoreMIDI.framework/Headers/CoreMIDI.h'):
			print 'Did not find CoreMIDI framework, exiting! (Please install it)'
			Exit(1)
		else:
			env.Append(LINKFLAGS = '-framework CoreMIDI -framework CoreFoundation -framework CoreAudio -framework Carbon -framework Quicktime -framework AudioToolbox -framework AudioUnit') #Have to add the rest of these frameworks somewhere...


	env = conf.Finish()


#Declare the flags for Mixxx's config/track listing files:
if platform == 'linux':
	env.Append(CXXFLAGS = ' -D__UNIX__ -D__LINUX__ -DSETTINGS_FILE=\\".mixxx.cfg\\" -DTRACK_FILE=\\".mixxxtrack.xml\\"')
	env.Append(CXXFLAGS = ' -DUNIX_SHARE_PATH=\\"' + ARGUMENTS.get('prefix', '/usr/local') + '/share/mixxx\\"')
elif platform == 'osx':
	env.Append(CXXFLAGS = ' -D__MACX__ -DSETTINGS_FILE=\\"mixxx.cfg\\" -DTRACK_FILE=\\"mixxxtrack.xml\\"')
elif platform == 'win32':
	env.Append(CXXFLAGS = '-D__WIN32__ -DSETTINGS_FILE=\\"mixxx.cfg\\" -DTRACK_FILE=\\"mixxxtrack.xml\\"')

#... and yes, we need to double-escape those quotes
env.Append(CXXFLAGS = ' -D__PORTAUDIO__'); #Turn on PortAudio support in Mixxx
env.Append(CPPPATH = ['.', '../', '../../']) #Fun fun fun with paths


if not platform == 'win32':
	env.Append(LIBS = 'Qt3Support');
	env.Append(LIBS = 'QtXml');
	env.Append(LIBS = 'QtGui');
	env.Append(LIBS = 'QtCore');
	env.Append(LIBS = 'QtOpenGL');

if platform == 'win32':
	env.Append(LIBS = 'Qt3Support4'); #Win32 needs this instead of 'Qt3Support'
	env.Append(LIBS = 'QtXml4');
	env.Append(LIBS = 'QtGui4');
	env.Append(LIBS = 'QtCore4');
	env.Append(LIBS = 'QtOpenGL4');
	env.Append(LIBS = 'WinMM'); #Needed for Midi stuff
	env.Append(LIBS = 'ogg_static')
	env.Append(LIBS = 'vorbis_static')
	env.Append(LIBS = 'vorbisfile_static')
	env.Append(LIBS = 'imm32')
	env.Append(LIBS = 'wsock32')
	env.Append(LIBS = 'delayimp')
	env.Append(LIBS = 'winspool')
	env.Append(LIBS = 'shell32')

env.Append(CXXFLAGS = ' -DQT3_SUPPORT -DQT3_SUPPORT_WARNINGS -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_TABLET_SUPPORT') #Stolen from Mixxx's build output
env.Append(CXXFLAGS = ' -I$QTDIR/include/Qt3Support -I$QTDIR/include/QtCore -I$QTDIR/include/QtGui -I$QTDIR/include/QtXml -I$QTDIR/include/QtOpenGl -I$QTDIR/include/Qt -I"$VCINSTALLDIR/include/atl"')

if not platform == 'win32':
	env.Append(CCFLAGS = Split(""" -pipe -O3 -Wall -W -g -D_REENTRANT """)) # omghax 
	env.Append(LINKFLAGS = Split(""" -pipe -O3 -Wall -W -g """))
if platform == 'win32':
	env.Append(CXXFLAGS = '-DWIN32 -D__WIN__ -DUNICODE -D_WINDOWS') #for soundtouch
	env.Append(CCFLAGS  = '-DWIN32 -D__WIN__ -DUNICODE -D_WINDOWS') #for soundtouch

#Uic these guys (they're moc'd automatically after this) - Generates the code for the QT UI forms
env.Uic4('dlgpreferencesdlg.ui')
env.Uic4('dlgprefsounddlg.ui')
env.Uic4('dlgprefmididlg.ui')
env.Uic4('dlgprefplaylistdlg.ui')
env.Uic4('dlgprefcontrolsdlg.ui')
env.Uic4('dlgprefmixerdlg.ui')
env.Uic4('dlgprefbpmdlg.ui')
env.Uic4('dlgbpmtapdlg.ui')
env.Uic4('dlgprefvinyldlg.ui')

#Add the QRC file which compiles in some extra resources (prefs icons, etc.)
env.Qrc(Split(""" mixxx.qrc """))
sources += Split(""" qrc_mixxx.cc """)

# Uic4 does not need this --> Add these uic/moc generated files to the list of stuff we need to build:
#sources.append(Split("""uic_dlgprefsounddlg.cc 		moc_dlgprefsounddlg.cc
#						uic_dlgprefcontrolsdlg.cc	moc_dlgprefcontrolsdlg.cc
#						uic_dlgprefmididlg.cc		moc_dlgprefmididlg.cc
#						uic_dlgprefplaylistdlg.cc	moc_dlgprefplaylistdlg.cc
#						uic_dlgprefmixerdlg.cc	    moc_dlgprefmixerdlg.cc
#						uic_dlgprefrecorddlg.cc	    moc_dlgprefrecorddlg.cc
#					  	"""))

#More complicated way of doing Uic (gives us control over the filenames, but doesn't really matter...)
#env.Uic(target = Split('dlgprefcontrolsdlg.h .ui/dlgprefcontrolsdlg.cpp .moc/dlgprefcontrolsdlg.cpp'),
#        source = 'dlgprefcontrolsdlg.ui')

#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

#SoundTouch
env.Append(CPPPATH=['../../lib/soundtouch']) #Needed two ../../'s because we're compiling from "src/.obj"
sources += Split("""enginebufferscalest.cpp ../../lib/soundtouch/SoundTouch.cpp ../../lib/soundtouch/TDStretch.cpp ../../lib/soundtouch/RateTransposer.cpp ../../lib/soundtouch/AAFilter.cpp ../../lib/soundtouch/FIFOSampleBuffer.cpp ../../lib/soundtouch/FIRFilter.cpp """)
if platform == 'win32':
	sources += Split("""../../lib/soundtouch/cpu_detect_x86_win.cpp ../../lib/soundtouch/mmx_win.cpp ../../lib/soundtouch/sse_win.cpp ../../lib/soundtouch/3dnow_win.cpp""")
else:
	sources += Split("""../../lib/soundtouch/cpu_detect_x86_gcc.cpp""")

#KissFFT
env.Append(CPPPATH=['../../lib/kissfft'])
sources += Split("""../../lib/kissfft/kiss_fft.c""")

#Xing's non-free VBR header SDK thing (we need to get rid of this!)
env.Append(CPPPATH='../../lib/vbrheadersdk/')
sources += Split("""../../lib/vbrheadersdk/dxhead.c""")

#libsamplerate
env.Append(CPPPATH='../../lib/libsamplerate')
sources += Split("""enginebufferscalesrc.cpp ../../lib/libsamplerate/samplerate.c ../../lib/libsamplerate/src_linear.c ../../lib/libsamplerate/src_sinc.c ../../lib/libsamplerate/src_zoh.c""")

#fidlib (for EQs)
env.Append(CPPPATH='../../lib/fidlib-0.9.9/')
sources += Split("""../../lib/fidlib-0.9.9/fidlib.c """)
#Platform-specific compile/link flags needed for fidlib
if platform == 'linux' or platform == 'osx':
	env.Append(CCFLAGS = '-DT_LINUX')
elif platform == 'win32':
	env.Append(CCFLAGS = '-DT_MSVC')
	env.Append(CXXFLAGS = '-DT_MSVC')
	env.Append(LINKFLAGS = ['/nodefaultlib:LIBCMT.lib', '/nodefaultlib:LIBCMTD.lib'])


#Parse command-line build flags


print "\nFeatures Summary:\n================"

#Python/lua scripting
#flags_script = ARGUMENTS.get('script', 0) #Default value is 0
#if int(flags_script):
#	env.Append(CXXFLAGS = '-D__SCRIPT__ -D__LUA__ -D__PYTHON__')
#	sources += Split("""script/*.cpp script/lua/*.cpp script/python/*.cpp""")
#	env.ParseConfig('python-config --include --ldflags')
#	env.Append(LIBS = 'lua')
#	env.Append(LIBS = 'lualib')
#	env.Append(LIBS = 'tulua')
#	print "Python and Lua scripting... enabled"
#else:
#	print "Python and Lua scripting... disabled"
 #TODO: FINISH THIS!


#Hercules support through libdjconsole on Linux
#(handled somewhere else above this in the file...
# just printing the summary here)
flags_djconsole = ARGUMENTS.get('djconsole', 0)
if int(flags_djconsole) == 0:
	print "libdjconsole support... disabled"
else:
	print "libdjconsole support... enabled"

#High quality EQs
flags_hifieq = ARGUMENTS.get('hifieq', 0)
if int(flags_hifieq) == 0:
	env.Append(CXXFLAGS = '-D__LOFI__ -D__NO_INTTYPES__') #Enables old crappy EQs
	print "High quality EQs... disabled"
else:
	print "High quality EQs... enabled"

#Experimental BPM detection
flags_experimentalbpm = ARGUMENTS.get('experimentalbpm', 1)
if int(flags_experimentalbpm):
	env.Append(CXXFLAGS = '-D__EXPERIMENTAL_BPM__')
	sources += Split(""" dlgbpmtap.cpp dlgprefbpm.cpp """)
	print "Experimental BPM detection... enabled"
else:
	print "Experimental BPM detection... disabled"

#Experimental Recording
flags_experimentalrecording = ARGUMENTS.get('experimentalrecord', 0)
if int(flags_experimentalrecording):
	env.Append(CXXFLAGS = '-D__EXPERIMENTAL_RECORDING__')
	env.Uic4('dlgprefrecorddlg.ui')
	sources += Split(""" dlgprefrecord.cpp enginerecord.cpp writeaudiofile.cpp """ )
	print "Experimental recording... enabled"
else:
	print "Experimental recording... disabled"

'''
#Experimental Shoutcast
flags_shoutcast = ARGUMENTS.get('shoutcast', 0)
if int(flags_shoutcast):
#TODO: check for libshout
	env.Append(CXXFLAGS = '-D__SHOUTCAST__')
	env.Uic4('dlgprefshoutcastdlg.ui')
	sources += Split(""" dlgprefshoutcast.cpp engineshoutcast.cpp """ )
	print "Shoutcast support... enabled"
else:
	print "Shoutcast support... disabled"
'''

#LADSPA
#TODO: Make sure we check for ladspa.h and the library...
flags_ladspa = ARGUMENTS.get('ladspa', 0)
if int(flags_ladspa):
	env.Append(CXXFLAGS = '-D__LADSPA__')
	sources += Split("""engineladspa.cpp ladspaloader.cpp ladspalibrary.cpp ladspaplugin.cpp ladspainstance.cpp ladspacontrol.cpp ladspainstancestereo.cpp ladspainstancemono.cpp ladspaview.cpp ladspapreset.cpp ladspapresetmanager.cpp ladspapresetknob.cpp ladspapresetinstance.cpp dlgladspa.cpp""")
	print "LADSPA support... enabled"
else:
	print "LADSPA support... disabled"

#Vinyl Control
flags_vinylcontrol = ARGUMENTS.get('vinylcontrol', 0)
if int(flags_vinylcontrol):
	env.Append(CXXFLAGS = '-D__VINYLCONTROL__')
	sources += Split(""" vinylcontrol.cpp vinylcontrolproxy.cpp vinylcontrolscratchlib.cpp vinylcontrolxwax.cpp dlgprefvinyl.cpp 
	                     enginevinylcontrol.cpp """)
	env.Append(CPPPATH='../../lib/xwax')
	sources += Split("""../../lib/xwax/timecoder.c """)
	env.Append(CPPPATH='../../lib/scratchlib')
	sources += Split("""../../lib/scratchlib/DAnalyse.cpp """)
	print "Vinyl Control... enabled"
else:
	print "Vinyl Control... disabled"


#ffmpeg support
flags_ffmpeg = ARGUMENTS.get('ffmpeg', 0)
if int(flags_ffmpeg):
        env.Append(LIBS = 'avcodec')
        env.Append(LIBS = 'avformat')
        env.Append(LIBS = 'z')
        env.Append(LIBS = 'a52')
        env.Append(LIBS = 'dts')
        env.Append(LIBS = 'gsm')
        env.Append(LIBS = 'dc1394_control')
        env.Append(LIBS = 'dl')
        env.Append(LIBS = 'vorbisenc')
        env.Append(LIBS = 'raw1394')
        env.Append(LIBS = 'avutil')
        env.Append(LIBS = 'vorbis')
        env.Append(LIBS = 'm')
        env.Append(LIBS = 'ogg')
        env.Append(CXXFLAGS = '-D__FFMPEGFILE__')
	sources += Split("""soundsourceffmpeg.cpp """)
	print "Experimental FFMPEG support... enabled"
else:
	print "Experimental FFMPEG support... disabled"

# Profiling and Optimization
if not platform == 'win32':
	flags_gprof = ARGUMENTS.get('gprof', 0)
	if int(flags_gprof):
		env.Append(CCFLAGS = '-pg')
		env.Append(LINKFLAGS = '-pg')
		print "gprof profiling support... enabled"
	else:
		print "gprof profiling support... disabled"
	flags_tuned = ARGUMENTS.get('tuned', 0)
        if int(flags_tuned):
		ccv = env['CCVERSION'].split('.')
		if int(ccv[0]) >= 4 and int(ccv[1]) >= 2:
			env.Append(CCFLAGS = '-march=native')
                        env.Append(LINKFLAGS = '-march=native')
			print "Optimizing for this CPU... yes"
                else:
			print "Optimizing for this CPU... no (requires gcc >= 4.2.0)"
	else:
		print "Optimizing for this CPU... no"

#Visual Studio 2005 hacks (MSVS Express Edition users shouldn't enable this)
flags_msvshacks = ARGUMENTS.get('msvshacks', 0)
if int(flags_msvshacks):
	env.Append(CXXFLAGS = '-D__MSVS2005__')
	print "MSVS 2005 hacks... enabled"
else:
	print "MSVS 2005 hacks... disabled"

print "================\n"

#Hijack scons -h and --help
opts = Options('custom.py')
opts.Add('prefix', 'Set to your install prefix', '/usr/local')
opts.Add('qtdir', 'Set to your QT4 directory', '/usr/share/qt4')
opts.Add('djconsole', 'Set to 1 to enable Hercules support through libdjconsole', 0)
opts.Add('experimentalbpm', '(EXPERIMENTAL) Set to 1 to enable new BPM detection', 1)
opts.Add('experimentalrecord', '(EXPERIMENTAL) Set to 1 to enable output recording feature', 0)
opts.Add('hifieq', '(EXPERIMENTAL) Set to 1 to enable high quality EQs', 0)
opts.Add('ladspa', '(EXPERIMENTAL) Set to 1 to enable LADSPA plugin support', 0)
opts.Add('ffmpeg', '(EXPERIMENTAL) Set to 1 to enable FFMPEG support', 0)
opts.Add('vinylcontrol', '(EXPERIMENTAL) Set to 1 to enable vinyl control support', 0)
opts.Add('msvshacks', 'Set to 1 to build properly with MS Visual Studio 2005 (Express users should leave this off)', 0)
if not platform == 'win32':
	opts.Add('gprof', '(DEVELOPER) Set to 1 to enable profiling using gprof', 0)
	opts.Add('tuned', '(EXPERIMENTAL) Set to 1 to optimise mixxx for this CPU', 0)
#env = Environment(options = opts)
Help(opts.GenerateHelpText(env))


#Tell SCons to build Mixxx
#=========================
if platform == 'win32':
	mixxx_bin = env.Program('mixxx', sources, LINKCOM  = [env['LINKCOM'], 'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;1'])
else:
	mixxx_bin = env.Program('mixxx', sources)

#Set up the MSVC target to build a Visual Studio project/solution file
if 'msvc' in COMMAND_LINE_TARGETS:
	includes = glob.glob('src/*.h')
	includes += glob.glob('src/visual/*.h')
	#Make the project file aware of any command-line arguments that were passed...
	cmdargs = ""
	for k in SCons.Script.ARGUMENTS:
		cmdargs += " " + k + "=" + SCons.Script.ARGUMENTS[k]
	env.Append(MSVSSCONSFLAGS = cmdargs)
	#env.Append(MSVSSCONSFLAGS = ' qtdir=' + flags_qtdir)
	msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = flatten(sources), incs = flatten(includes), variant = 'Debug', runfile = '../dist/mixxx')
	env.Alias('msvc', msvc)

#Set up the install target
#=========================
"""
flags_prefix = ARGUMENTS.get('prefix', '/usr/local')
if not os.path.exists(flags_prefix):
	print "Error: Prefix path does not exist!"
	Exit(1)
else:
	unix_share_path = flags_prefix + "/share"
	unix_bin_path   = flags_prefix + "/bin"
"""

#Mixxx binary
binary_files = mixxx_bin;

	#Skins
skin_files = glob.glob('../skins/*')

	#MIDI mappings
midimappings_files = glob.glob('../midi/*')

	#Keyboard mapping(s)
keyboardmappings_files = glob.glob('../keyboard/*')

	#Documentation
docs_files = glob.glob('../../LICENSE')
docs_files += glob.glob('../../README')
docs_files += glob.glob('../../Mixxx-Manual.pdf')

	#.desktop file for KDE/GNOME menu
dotdesktop_files = glob.glob('../mixxx.desktop')

	#Icon file for menu entry
icon_files = glob.glob('../mixxx-icon.png')

#Images for preferences dialog
image_files = glob.glob('../images/preferences/*')

#Windows DLLs
dll_files = glob.glob('../../../mixxx-winlib/*.dll') # TODO: Use reference to SharedLibrary for libsndfile and others, glob only gets all files on 2+ builds after a clean.
# dll_files = libsndfile
dll_files += Split("""$QTDIR/lib/Qt3Support4.dll $QTDIR/lib/QtCore4.dll $QTDIR/lib/QtGui4.dll $QTDIR/lib/QtNetwork4.dll $QTDIR/lib/QtOpenGL4.dll $QTDIR/lib/QtSql4.dll $QTDIR/lib/QtXml4.dll """)

if platform == 'linux' or platform == 'osx':
	flags_prefix = ARGUMENTS.get('prefix', '/usr/local')
	if not os.path.exists(flags_prefix):
		print "Error: Prefix path does not exist!"
		Exit(1)
	else:
		unix_share_path = flags_prefix + "/share"
		unix_bin_path   = flags_prefix + "/bin"

		binary = env.Install(unix_bin_path, binary_files)
		skins = env.Install(unix_share_path + "/mixxx/skins", skin_files)
		midimappings = env.Install(unix_share_path + "/mixxx/midi", midimappings_files)
		keyboardmappings = env.Install(unix_share_path + "/mixxx/keyboard", keyboardmappings_files)
		docs = env.Install(unix_share_path + "/doc/mixxx", docs_files)
		dotdesktop = env.Install(unix_share_path + "/applications", dotdesktop_files)
		icon = env.Install(unix_share_path + "/pixmaps", icon_files)

        #Makes each of those Install builders get fired off when you run "scons install" :)
		env.Alias('install', binary)
		env.Alias('install', skins)
		env.Alias('install', midimappings)
		env.Alias('install', keyboardmappings)
		env.Alias('install', docs)
		env.Alias('install', dotdesktop)
		env.Alias('install', icon)

if platform == 'win32':
	skins = env.Install("../../dist/skins", skin_files)
	midimappings = env.Install("../../dist/midi", midimappings_files)
	keyboardmappings = env.Install("../../dist/keyboard", keyboardmappings_files)
	docs = env.Install("../../dist/doc/", docs_files)
	#icon = env.Install("../../dist", icon_files)
	dlls = env.Install("../../dist/", dll_files)
	binary = env.Install("../../dist/", binary_files)

	#Always trigger these install builders when compiling on Windows
	env.Alias('mixxx', skins)
	env.Alias('mixxx', midimappings)
	env.Alias('mixxx', keyboardmappings)
	env.Alias('mixxx', docs)
	env.Alias('mixxx', dlls)
	#env.Alias('mixxx', icon)
	env.Alias('mixxx', binary)


