#EXAMPLES of random stuff that might be useful later in Mixxx's SConstruct file
#==============================================================================
"""
#Example: Checking for a C header
if not conf.CheckCHeader('math.h'):
    print 'Math.h must be installed!'
    Exit(1)
if conf.CheckCHeader('foo.h'):
    conf.env.Append('-DHAS_FOO_H')
"""

"""
#Example: Checking for a C++ header
if not conf.CheckCXXHeader('vector.h'):
    print 'vector.h must be installed!'
    Exit(1)
"""

"""
#Example: Checking for a library
if not conf.CheckLib('m'):
    print 'Did not find libm.a or m.lib, exiting!'
    Exit(1)
"""

"""
#Example: Checking for a library AND a header (probably what we want to do)
if not conf.CheckLibWithHeader('m', 'math.h'):
    print 'Did not find libm.a or m.lib, exiting!'
    Exit(1)
"""

import os
import sys
import SCons

# BIG FAT WARNING:
# Make sure you use TABS for indentation, NOT spaces! (Python doesn't like spaces, be forewarned!)
#
#   ####       ####  ##########  #####    #####  #####    #####  #####    #####
#   ######   ######     ####      #####  #####    #####  #####    #####  #####
#   #### ## ## ####     ####        ########        ########        ########
#   ####   #   ####     ####      #####  #####    #####  #####    #####  #####
#   ####       ####  ##########  #####    #####  #####    #####  #####    #####
#
#  #############################################################################
#    #########################################################################
#  
#Start of Mixxx's real SConstruct file
#=======================================


#Checks for OpenGL on all three platforms
def CheckOpenGL():
	if not conf.CheckLib('GL') and not conf.CheckLib('opengl32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/gl.h'):
		print 'Did not find OpenGL development files, exiting!'
		Exit(1)

	if not conf.CheckLib('GLU') and not conf.CheckLib('glu32') and not conf.CheckCHeader('/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/glu.h'):
		print 'Did not find GLU development files, exiting!'
		Exit(1)
	#Workaround for SCONS not detecting frameworks on OS X
	if platform == 'osx':
		env.Append(LINKFLAGS = '-framework OpenGL')

	return
	
#Checks for OpenGL on all three platforms
def CheckOggVorbis():
	#Check for Ogg and Vorbis on Linux and Win32
	if platform == 'linux' or platform == 'win32':
		if not conf.CheckLib('vorbisfile'):
			print 'Did not find libvorbisfile.a, libvorbisfile.lib, or the libvorbisfile development headers, exiting!'
			Exit(1)
	
		if not conf.CheckLib('ogg'):
			print 'Did not find libogg.a, libogg.lib, or the libogg development headers, exiting!'
			Exit(1)
    
	elif platform == 'osx':
		#Check for Ogg and Vorbis on OS X
		if not conf.CheckCHeader('/Library/Frameworks/Vorbis.framework/Versions/A/Headers/vorbisfile.h'):
			print 'Did not find Vorbis framework, exiting! (Please install it)'
			Exit(1)
		else:
			env.Append(LINKFLAGS = '-framework Vorbis')
	
		#Check for Ogg
		if not conf.CheckCHeader('/Library/Frameworks/Ogg.framework/Versions/A/Headers/ogg.h'):
			print 'Did not find Ogg framework, exiting! (Please install it)'
			Exit(1)
		else:
			env.Append(LINKFLAGS = '-framework Ogg')
				
	return

def flatten(x):
	"""flatten(sequence) -> list

	Returns a single, flat list which contains all elements retrieved
	from the sequence and all recursively contained sub-sequences
    (iterables).

    Examples:
    >>> [1, 2, [3,4], (5,6)]
    [1, 2, [3, 4], (5, 6)]
    >>> flatten([[[1,2,3], (42,None)], [4,5], [6], 7, MyVector(8,9,10)])
    [1, 2, 3, 42, None, 4, 5, 6, 7, 8, 9, 10]"""

	result = []
	for el in x:
		#if isinstance(el, (list, tuple)):
		if hasattr(el, "__iter__"):
			result.extend(flatten(el))
		else:
			result.append(el)
	return result


#Get the platform/OS that we're building on:
if os.name == 'nt':
	print 'Platform: Windows'
	platform = 'win32'
elif sys.platform == 'linux2':
	print 'Platform: Linux'
	platform = 'linux'
elif sys.platform == 'darwin':
	print 'Platform: OS X'
	platform = 'osx'
else:
	print 'Platform: Unknown (assuming Linux-like)'
	platform = 'linux'


#Figure out what the QT path is
flags_qtdir = ARGUMENTS.get('qtdir', '/usr/share/qt3')
if not os.path.exists(flags_qtdir):
	print "Error: QT path does not exist."
	print "Please specify your QT path by running \"scons qtdir=[path]\""
	Exit(1)
else:
	print "QT path: " + flags_qtdir


#Set up our environment, tell SCONS to use it's QT tools, and set some enviroment variables for it.
env = Environment(tools=['default','qt', 'msvs'], QTDIR=flags_qtdir, QT_LIB='qt-mt')
       

#env.Append(CPPPATH='.')

#Mixxx sources to build
sources = Split("""enginebuffercue.cpp input.cpp mixxxmenuplaylists.cpp trackplaylistlist.cpp mixxxkeyboard.cpp configobject.cpp controlobjectthread.cpp controlobjectthreadwidget.cpp controlobjectthreadmain.cpp controlevent.cpp controllogpotmeter.cpp controlobject.cpp controlnull.cpp controlpotmeter.cpp controlpushbutton.cpp controlttrotary.cpp controlbeat.cpp dlgpreferences.cpp dlgprefsound.cpp dlgprefmidi.cpp dlgprefplaylist.cpp dlgprefcontrols.cpp dlgprefmixer.cpp enginebuffer.cpp enginebufferscale.cpp engineclipping.cpp enginefilterblock.cpp enginefilteriir.cpp  enginefilter.cpp engineobject.cpp enginepregain.cpp enginevolume.cpp main.cpp midiobject.cpp midiobjectnull.cpp mixxx.cpp mixxxview.cpp player.cpp playerproxy.cpp playerportaudio.cpp soundsource.cpp soundsourcemp3.cpp soundsourceoggvorbis.cpp enginechannel.cpp enginemaster.cpp enginerecord.cpp wwidget.cpp wpixmapstore.cpp wlabel.cpp wnumber.cpp wnumberpos.cpp wnumberrate.cpp wnumberbpm.cpp wknob.cpp wdisplay.cpp wvumeter.cpp wpushbutton.cpp wslidercomposed.cpp wslider.cpp wtracktable.cpp wtracktableitem.cpp wstatuslight.cpp enginedelay.cpp engineflanger.cpp enginespectralfwd.cpp mathstuff.cpp readerextract.cpp readerextractwave.cpp readerevent.cpp rtthread.cpp windowkaiser.cpp probabilityvector.cpp reader.cpp trackinfoobject.cpp enginevumeter.cpp peaklist.cpp rotary.cpp log.cpp track.cpp trackcollection.cpp trackplaylist.cpp xmlparse.cpp wtreeview.cpp wtreeitem.cpp wtreeitemfile.cpp wtreeitemdir.cpp wtreeitemplaylist.cpp wtreeitemplaylistroot.cpp trackimporter.cpp parser.cpp parserpls.cpp parserm3u.cpp mixxxsocketserver.cpp mixxxsocketclient.cpp dlgprefrecord.cpp writeaudiofile.cpp 
 enginetemporal.cpp visual/visualbuffertemporal.cpp wavesummary.cpp bpmdetect.cpp peakfinder.cpp wavesegmentation.cpp soundsourceproxy.cpp woverview.cpp enginebeatseek.cpp
 enginebufferscalereal.cpp powermate.cpp  hercules.cpp joystick.cpp mouse.cpp 
 wvisualsimple.cpp wvisualwaveform.cpp visual/visualbackplane.cpp visual/texture.cpp visual/visualbox.cpp visual/visualbuffer.cpp visual/visualbuffersignal.cpp visual/visualbuffersignalhfc.cpp visual/visualbuffermarks.cpp visual/visualchannel.cpp visual/visualcontroller.cpp visual/visualdisplay.cpp visual/visualdisplaybuffer.cpp visual/light.cpp visual/material.cpp visual/picking.cpp visual/pickable.cpp visual/visualobject.cpp
 imginvert.cpp imgloader.cpp imgcolor.cpp wskincolor.cpp """)


#Compile platform specific hardware support
if platform == 'linux':
	sources += Split("""powermatelinux.cpp herculeslinux.cpp joysticklinux.cpp mouselinux.cpp """)
#elif platform == 'win32':
#	sources += Split("""powermatewin.cpp mousewin.cpp """)

#Compile platform specific MIDI support
if platform == 'linux':
	sources += Split("""midiobjectalsaseq.cpp """)  #ALSA Sequencer MIDI support for Linux
	env.Append(CXXFLAGS = '-D__ALSASEQMIDI__')
elif platform == 'win32':
	sources += Split("""midiobjectwin.cpp """)      #Windows MIDI support
	env.Append(CXXFLAGS = '-D__WINMIDI__')
elif platform == 'osx':
	sources += Split("""midiobjectcoremidi.cpp """) #CoreMidi support for OS X
	env.Append(CXXFLAGS = '-D__COREMIDI__')


#Check for dependencies if we're not doing a clean...

if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
	conf = Configure(env)

	if not conf.CheckLibWithHeader('portaudio', 'portaudio.h', 'C'):
		print 'Did not find libportaudio.a or portaudio.lib, exiting!'
		Exit(1)

	if not conf.CheckLib('qt-mt'):
		print 'Did not find libqt-mt.a or libqt-mt.lib, exiting!'
		Exit(1)

	if not conf.CheckLib('mad'):
		print 'Did not find libmad.a or libmad.lib, exiting!'
		Exit(1)

	if not conf.CheckLib('id3tag'):
		print 'Did not find libid3tag.a or libid3tag.lib, exiting!'
		Exit(1)
	
	#Check for Ogg and Vorbis
	CheckOggVorbis()

	#Check for OpenGL (it's messy to do it for all three platforms)
	CheckOpenGL()

	#Platform-specific checks for Linux...
	if platform == 'linux':
	    #Check for libsndfile
		if not conf.CheckLibWithHeader('sndfile', 'sndfile.h', 'C'):
			print 'Did not find libsndfile or it\'s development headers, exiting!'
			Exit(1)
		else:
			env.Append(CXXFLAGS = ' -D__SNDFILE__')
			sources.append('soundsourcesndfile.cpp')
			
		#Check for libdjconsole, if it was passed as a flag
		flags_djconsole = ARGUMENTS.get('djconsole', 0)
		if int(flags_djconsole):
			if not conf.CheckLibWithHeader('djconsole', 'libdjconsole/djconsole.h', 'C++'):
				print 'Did not find libdjconsole or it\'s development headers, exiting!'
				Exit(1)
			env.ParseConfig('pkg-config libdjconsole --silence-errors --cflags --libs')
			env.Append(CXXFLAGS = '-D__LIBDJCONSOLE__')         

		#Another check for PortAudio-v19
		env.ParseConfig('pkg-config --cflags --libs portaudio-2.0')
		#If the above line looks like magic, it's because it really is. (Read about ParseConfig, it's nifty)
    
	#Platform-specific checks for OS X
	if platform == 'osx':
	    #Check for libaudiofile
		if not conf.CheckLibWithHeader('audiofile', 'audiofile.h', 'C'):
			print 'Did not find libaudiofile or it\'s development headers, exiting!'
			Exit(1)
		else:
			env.Append(CXXFLAGS = ' -D__AUDIOFILE__')
			sources.append('soundsourceaudiofile.cpp')
		
		#Check for CoreMIDI
		if not conf.CheckCHeader('/System/Library/Frameworks/CoreMIDI.framework/Headers/CoreMIDI.h'):
			print 'Did not find CoreMIDI framework, exiting! (Please install it)'
			Exit(1)
		else:
			env.Append(LINKFLAGS = '-framework CoreMIDI -framework CoreFoundation -framework CoreAudio -framework Carbon -framework Quicktime -framework AudioToolbox -framework AudioUnit') #Have to add the rest of these frameworks somewhere...

		

	env = conf.Finish()


#Declare the flags for Mixxx's config/track listing files:
if platform == 'linux':
	env.Append(CXXFLAGS = ' -D__UNIX__ -D__LINUX__ -DSETTINGS_FILE=\\".mixxx.cfg\\" -DTRACK_FILE=\\".mixxxtrack.xml\\"')
	env.Append(CXXFLAGS = ' -DUNIX_SHARE_PATH=\\"/usr/share/mixxx\\"')
elif platform == 'osx':
	env.Append(CXXFLAGS = ' -D__MACX__ -DSETTINGS_FILE=\\"mixxx.cfg\\" -DTRACK_FILE=\\"mixxxtrack.xml\\"')


#... and yes, we need to double-escape those quotes
env.Append(CXXFLAGS = ' -D__PORTAUDIO__'); #Turn on PortAudio support in Mixxx
env.Append(CPPPATH = ['.', '../', '../../']) #Fun fun fun with paths

env.Append(LIBS = 'qt-mt')
env.Append(CXXFLAGS = ' -DQT_THREAD_SUPPORT -DQT_SHARED -DQT_TABLET_SUPPORT') #Stolen from Mixxx's build output
env.Append(CXXFLAGS = ' -pipe -O3 -pipe -Wall -W -g -D_REENTRANT') # omghax

#Uic these guys (they're moc'd automatically after this) - Generates the code for the QT UI forms
env.Uic('dlgprefsounddlg.ui')
env.Uic('dlgprefmididlg.ui')
env.Uic('dlgprefplaylistdlg.ui')
env.Uic('dlgprefcontrolsdlg.ui')
env.Uic('dlgprefmixerdlg.ui')	

env.Uic('dlgprefrecorddlg.ui')

#Add these uic/moc generated files to the list of stuff we need to build:
sources.append(Split("""uic_dlgprefsounddlg.cc 		moc_dlgprefsounddlg.cc
						uic_dlgprefcontrolsdlg.cc	moc_dlgprefcontrolsdlg.cc
						uic_dlgprefmididlg.cc		moc_dlgprefmididlg.cc
						uic_dlgprefplaylistdlg.cc	moc_dlgprefplaylistdlg.cc
						uic_dlgprefmixerdlg.cc	    moc_dlgprefmixerdlg.cc
						uic_dlgprefrecorddlg.cc	    moc_dlgprefrecorddlg.cc
					  	"""))

#More complicated way of doing Uic (gives us control over the filenames, but doesn't really matter...)
#env.Uic(target = Split('dlgprefcontrolsdlg.h .ui/dlgprefcontrolsdlg.cpp .moc/dlgprefcontrolsdlg.cpp'),
#        source = 'dlgprefcontrolsdlg.ui')

#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

#SoundTouch
env.Append(CPPPATH=['../../lib/soundtouch']) #Needed two ../../'s because we're compiling from "src/.obj"
sources += Split("""enginebufferscalest.cpp ../../lib/soundtouch/SoundTouch.cpp ../../lib/soundtouch/TDStretch.cpp ../../lib/soundtouch/RateTransposer.cpp ../../lib/soundtouch/AAFilter.cpp ../../lib/soundtouch/FIFOSampleBuffer.cpp ../../lib/soundtouch/FIRFilter.cpp """)
if platform == 'win32':
	sources += Split("""../../lib/soundtouch/cpu_detect_x86_win.cpp ../../lib/soundtouch/mmx_win.cpp ../../lib/soundtouch/sse_win.cpp ../../lib/soundtouch/3dnow_win.cpp""")
else:
	sources += Split("""../../lib/soundtouch/cpu_detect_x86_gcc.cpp""")

#KissFFT
env.Append(CPPPATH=['../../lib/kissfft'])
sources += Split("""../../lib/kissfft/kiss_fft.c ../../lib/kissfft/kiss_fftr.c""")

#Xing's non-free VBR header SDK thing (we need to get rid of this!)
env.Append(CPPPATH='../../lib/vbrheadersdk/')
sources += Split("""../../lib/vbrheadersdk/dxhead.c""")

#libsamplerate
env.Append(CPPPATH='../../lib/libsamplerate')
sources += Split("""enginebufferscalesrc.cpp ../../lib/libsamplerate/samplerate.c ../../lib/libsamplerate/src_linear.c ../../lib/libsamplerate/src_sinc.c ../../lib/libsamplerate/src_zoh.c""")

#fidlib (for EQs)
env.Append(CPPPATH='../../lib/fidlib-0.9.9/')
sources += Split("""../../lib/fidlib-0.9.9/fidlib.c """)
#Platform-specific defines needed for fidlib
if platform == 'linux' or platform == 'osx':
	env.Append(CCFLAGS = '-DT_LINUX')
elif platform == 'win32':
	env.Append(CCFLAGS = '-DT_MSVC')


#Parse command-line build flags


print "\nFeatures Summary:\n================"

#Python/lua scripting
#flags_script = ARGUMENTS.get('script', 0) #Default value is 0
#if int(flags_script):
#	env.Append(CXXFLAGS = '-D__SCRIPT__ -D__LUA__ -D__PYTHON__')
#	sources += Split("""script/*.cpp script/lua/*.cpp script/python/*.cpp""")
#	env.ParseConfig('python-config --include --ldflags')
#	env.Append(LIBS = 'lua')
#	env.Append(LIBS = 'lualib')
#	env.Append(LIBS = 'tulua')
#	print "Python and Lua scripting... enabled"
#else:
#	print "Python and Lua scripting... disabled"
 #TODO: FINISH THIS! 


      
#High quality EQs
flags_hifieq = ARGUMENTS.get('hifieq', 0)
if int(flags_hifieq) == 0:
	env.Append(CXXFLAGS = '-D__LOFI__ -D__NO_INTTYPES__') #Enables old crappy EQs
	print "High quality EQs... disabled"
else:
	print "High quality EQs... enabled"

#Experimental BPM detection
flags_experimentalbpm = ARGUMENTS.get('experimentalbpm', 0)
if int(flags_experimentalbpm):
	env.Append(CXXFLAGS = '-D__EXPERIMENTAL_BPM__')
	sources += Split("""bpmdetect.cpp """)
	print "Experimental BPM detection... enabled"
else:
	print "Experimental BPM detection... disabled"

print "================\n"

#Hijack scons -h and --help
opts = Options('custom.py')
opts.Add('djconsole', 'Set to 1 to enable Hercules support through libdjconsole', 0)
opts.Add('hifieq', 'Set to 1 to enable high quality EQs', 0)
opts.Add('experimentalbpm', 'Set to 1 to enable experimental BPM detection', 0)
opts.Add('qtdir', 'Set to your QT3 directory', '/usr/share/qt3')
opts.Add('prefix', 'Set to your install prefix', '/usr/local')
#env = Environment(options = opts)
Help(opts.GenerateHelpText(env))


#if 'msvc' in COMMAND_LINE_TARGETS:
#	includes = os.listdir("src")
#	includes = os.listdir("src/visual")
#	env.MSVSProject(target = 'Mixxx' + env['MSVSPROJECTSUFFIX'], srcs = flatten(sources), incs = ['*.h', 'visual/*.h'], variant = 'Debug')



#Tell SCons to build Mixxx
#=========================
mixxx_bin = env.Program('mixxx', sources)


#Set up the install targets
#=========================
"""
flags_prefix = ARGUMENTS.get('prefix', '/usr/local')
if not os.path.exists(flags_prefix):
	print "Error: Prefix path does not exist!"
	Exit(1)
else:
	unix_share_path = flags_prefix + "/share"
	unix_bin_path   = flags_prefix + "/bin"
	
	env.Install(unix_bin_path, mixxx_bin) #Mixxx binary
	
	#Skins
	env.Install(unix_share_path+ "/skins/outline", "skins/outline/*"
	#MIDI mappings
	
	#Keyboard mapping(s)
	
	#Documentation
	
	#.desktop file for KDE/GNOME menu
	
	#Icon file for menu entry

	#env.Install(prefix, goodbye)
	#env.Alias('install', prefix)

"""
#Copy mixxx from the .obj directory to the mixxx directory.
#Command("../../mixxx", ".obj/mixxx", Copy("$TARGET", "$SOURCE"))


