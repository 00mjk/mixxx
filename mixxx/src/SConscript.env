#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys, os, platform
import SCons.Script
import logging

from build import util, mixxx, depends

Import('build')
#Import('platform')
#Import('machine')	#CPU architecture for optimization
#Import('architecture')	#CPU type & binary format for optimization
#Import('bitwidth')      #CPU bit width that can be forced (use this for most build items)

#Check for FFMPEG support
def CheckFFMPEG(conf, sources):
	flags['ffmpeg'] = ARGUMENTS.get('ffmpeg', 0)
	if int(flags['ffmpeg']):
		if build.platform_is_linux or build.platform_is_osx:
			#Check for libavcodec, libavformat
			#I just randomly picked version numbers lower than mine for this - Albert
			if not conf.CheckForPKG('libavcodec', '51.20.0'):
				print 'libavcodec not found.'
				Exit(1)
			if not conf.CheckForPKG('libavformat', '51.1.0'):
				print 'libavcodec not found.'
				Exit(1)
			else:
				#Grabs the libs and cflags for ffmpeg
				env.ParseConfig('pkg-config libavcodec --silence-errors --cflags --libs')
				env.ParseConfig('pkg-config libavformat --silence-errors --cflags --libs')
				env.Append(CPPDEFINES = '__FFMPEGFILE__')
		else:
			# aptitude install libavcodec-dev libavformat-dev liba52-0.7.4-dev libdts-dev
			env.Append(LIBS = 'avcodec')
			env.Append(LIBS = 'avformat')
			env.Append(LIBS = 'z')
			env.Append(LIBS = 'a52')
			env.Append(LIBS = 'dts')
			env.Append(LIBS = 'gsm')
			env.Append(LIBS = 'dc1394_control')
			env.Append(LIBS = 'dl')
			env.Append(LIBS = 'vorbisenc')
			env.Append(LIBS = 'raw1394')
			env.Append(LIBS = 'avutil')
			env.Append(LIBS = 'vorbis')
			env.Append(LIBS = 'm')
			env.Append(LIBS = 'ogg')
			env.Append(CPPDEFINES = '__FFMPEGFILE__')
		sources += Split("""soundsourceffmpeg.cpp """)
		print "Not working FFMPEG support... enabled"
	else:
		print "Not working FFMPEG support... disabled"
	return


# Checks for pkg-config on Linux
def CheckForPKGConfig( context, version='0.0.0' ):
	context.Message( "Checking for pkg-config (at least version %s)... " % version )
	ret = context.TryAction( "pkg-config --atleast-pkgconfig-version=%s" %version )[0]
	context.Result( ret )
	return ret

# Uses pkg-config to check for a minimum version
def CheckForPKG( context, name, version="" ):
	if version == "":
		context.Message( "Checking for %s... \t" % name )
		ret = context.TryAction( "pkg-config --exists '%s'" % name )[0]
	else:
		context.Message( "Checking for %s (%s or higher)... \t" % (name,version) )
		ret = context.TryAction( "pkg-config --atleast-version=%s '%s'" % (version,name) )[0]
		context.Result( ret )
	return ret

flags = {}

# Grab the created environment from the MixxxBuild
env = build.env

env['MIXXX_VERSION'] = util.get_mixxx_version() #should this be in the env?
env['CPPDEFINES'] = [''] #Initialize this as a list, fixes a bug where first CPPDEFINE would get mangled

#Figure out what architecture we are, set up bitwith and platform variables
arch_stuff = util.determine_architecture(build.platform, ARGUMENTS, env)
architecture = arch_stuff['architecture']
machine = arch_stuff["machine"]
bitwidth = arch_stuff["bitwidth"]
build_dir = util.get_build_dir(build.platform, bitwidth)

Export('architecture')
#So architecture-specific decisions & optimizations can be made in the SConscript
Export('machine')
Export('bitwidth')
Export('build_dir')

## Avoid spreading .sconsign files everywhere
#env.SConsignFile(env['CACHEDIR']+'/scons_signatures')
## WARNING - We found that the above line causes SCons to randomly not find
##           dependencies for some reason. It might not happen right away, but
##           a good number of users found that it caused weird problems - Albert (May 15/08)


#Hijack scons -h and --help
cachefile = str(env['CACHEDIR']) + 'custom.py'
#opts = Options(cachefile)
vars = Variables(cachefile)
vars.Add('prefix', 'Set to your install prefix', '/usr/local')
vars.Add('qtdir', 'Set to your QT4 directory', '/usr/share/qt4')
vars.Add('hifieq', 'Set to 1 to enable high quality EQs', 1)
vars.Add('ipod', 'Set to 1 to enable iPod support through libgpod', 0)
vars.Add('ladspa', '(EXPERIMENTAL) Set to 1 to enable LADSPA plugin support', 0)
vars.Add('ffmpeg', '(EXPERIMENTAL) Set to 1 to enable FFMPEG support', 0)
vars.Add('vinylcontrol', 'Set to 1 to enable vinyl control support', 1)
vars.Add('shoutcast', 'Set to 1 to enable shoutcast support', 0)
vars.Add('cmetrics', 'Set to 1 to enable crash reporting/usage statistics via Case Metrics (This should be disabled on development builds)', 0)
vars.Add('asmlib','Set to 1 to enable linking against Agner Fog\'s hand-optimized asmlib, found at http://www.agner.org/optimize/', 0)
vars.Add('script', 'Set to 1 to enable MixxxScript/QtScript Studio support.', 0)
vars.Add('midiscript', 'Set to 1 to enable MIDI Scripting support.', 1)
vars.Add('tonal', 'Set to 1 to enable tonal analysis', 0)
vars.Add('qdebug', 'Set to 1 to enable verbose console debug output.', 1)
vars.Add('test', 'Set to 1 to build Mixxx test fixtures.', 0)
if not build.platform_is_windows:
	vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU (overrides "optimize")', 0)
	vars.Add('optimize', 'Set to:\n  1 for -O3 compiler optimizations\n  2 for Pentium 4 optimizations\n  3 for Intel Core optimizations\n  4 for Intel Core 2 optimizations\n  5 for Athlon-4/XP/MP optimizations\n  6 for K8/Opteron/AMD64 optimizations\n  7 for K8/Opteron/AMD64 w/ SSE3\n  8 for Celeron D (generic SSE/SSE2/SSE3) optimizations.', 1)
	vars.Add('profiling', '(DEVELOPER) Set to 1 to enable profiling using gprof (Linux) or Saturn (OS X)', 0)
else:
	if bitwidth == '64':
		vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU class', 0)
	vars.Add('optimize', 'Set to:\n  1 to maximize speed (/O2)\n  2 for maximum optimizations (/Ox)', 1)
	vars.Add('msvshacks', 'Set to 1 to build properly with MS Visual Studio 2005 (Express users should leave this off)', 0)
	vars.Add('msvcdebug', 'Set to 1 to link against MS libraries with debugging info (implies debug=1)', 0)
#env = Environment(options = opts)
vars.Update(env)
Help(vars.GenerateHelpText(env))

#Import environment variables from the terminal. Note that some variables
#correspond to variables inside the SCons env with different names,
# eg. the shell's "CFLAGS" ---> SCons' "CCFLAGS".
if os.environ.has_key('CC'):
	env['CC'] = os.environ['CC']
if os.environ.has_key('CFLAGS'):
	env['CCFLAGS'] += SCons.Util.CLVar(os.environ['CFLAGS'])
if os.environ.has_key('CXX'):
	env['CXX'] = os.environ['CXX']
if os.environ.has_key('CXXFLAGS'):
	env['CXXFLAGS'] += SCons.Util.CLVar(os.environ['CXXFLAGS'])
if os.environ.has_key('LDFLAGS'):
	env['LINKFLAGS'] += SCons.Util.CLVar(os.environ['LDFLAGS'])

#env.Append(CPPDEFINES=[('BUILD_REV', '"%s"' % getBZRRevision())]) #doing this forces a rebuild of everything whenever a commit happens -- not much fun
## instead, embed BZR version into build
## Put version info into a file, so it doesn't force a rebuild of everything :)
f = open("build.h","w")
try:
	f.write('#define BUILD_REV "' + util.get_bzr_revision() + '"\n')
finally:
	f.close()

#Check for dependencies if we're not doing a clean...
#if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig, 'CheckForPKG' : CheckForPKG })


mixxx_base_dependencies = [depends.MixxxCore]
visited_dependencies = set()
active_dependencies = []
unmet_dependencies = False

def visit_dependency(dependency_class, build, conf):
        """Recursively configure all dependencies. Skip over dependencies we
        have already setup."""
        if dependency_class in visited_dependencies:
                return
        visited_dependencies.add(dependency_class)
        dependency = dependency_class()
        try:
                dependency.configure(build, conf)
        except Exception, e:
                logging.error("Unmet dependency: %s" % e.message)
                unmet_dependencies = True
        active_dependencies.append(dependency)

        for sub_dependency in dependency.depends(build):
                visit_dependency(sub_dependency, build, conf)

for dependency in mixxx_base_dependencies:
        visit_dependency(dependency, build, conf)

if unmet_dependencies:
        logging.error("Build had unmet dependencies. Exiting.")
        Exit(1)

sources = []

# Query each enabled dependency for sources they require
for dependency in active_dependencies:
        dep_sources = dependency.sources(build)
        if dep_sources is not None:
                sources.extend(dep_sources)

#Check if FFMPEG was enabled
CheckFFMPEG(conf, sources)

#check for libshout
libshout_found = conf.CheckLib(['libshout','shout'])
vorbisenc = conf.CheckLib('vorbisenc')

#hack: check for these here, before conf.Finish happens
have_mp4v2_h = conf.CheckHeader('mp4v2/mp4v2.h')
have_mp4 = (have_mp4v2_h and conf.CheckLib(['mp4v2', 'libmp4v2'])) or conf.CheckLib('mp4')

# We have to check for libfaad version 2.6 or 2.7. In libfaad
# version 2.7, the type for the samplerate is unsigned long*,
# while in 2.6 the type is uint32_t*. We can use the optional
# call parameter to CheckLibWithHeader to build a test file to
# check which one this faad.h supports.

have_faad = conf.CheckLib(['faad', 'libfaad'])
have_faad_26 = False

# Check for libfaad version 2.6. This check doesn't work correctly on Windows
# And we build it manually anyway, so we know it's v2.7
if have_faad and not build.platform_is_windows:
	have_faad_26 = (not conf.CheckLibWithHeader(
                        'libfaad', 'faad.h', 'c++',
                        call = 'faacDecInit2(0, 0, 0, (unsigned long*)0, (unsigned char*)0);',
                        autoadd=False))

have_m4a = have_mp4 and have_faad
flags['m4a'] = util.get_flags(env, 'm4a', 0)
if int(flags['m4a']) and not have_m4a:
        if not have_mp4:
                print 'Did not find libmp4v2 or the libmp4v2 development headers, exiting!'
        if not have_faad:
                print 'Did not find libfaad or the libfaad development headers, exiting!'
        Exit(1)

have_wv = conf.CheckLib(['wavpack', 'wv'])
flags['wv'] = util.get_flags(env,'wv',0)

if int(flags['wv']):
	print "WavPack audio file support...",
	if have_wv:
		print "enabled"
	else:
		print "not found"
		Exit(1)
else:
	print "WavPack audio file support disabled"


env = conf.Finish()

#declare platform specific flags? though we shouldn't really need these, the compilers should Just Know...
#on __APPLE__ it works like that. probably we just need to look into what the default __platform__ #defines are and search and replace in the code
env.Append(CPPDEFINES=machine)

#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

#Parse command-line build flags
build_flags = ""

print "\nFeatures Summary:\n================"

#High quality EQs
flags['hifieq'] = util.get_flags(env, 'hifieq', 1)
if int(flags['hifieq']) == 0:
	env.Append(CPPDEFINES = ['__LOFI__', '__NO_INTTYPES__']) #Enables old crappy EQs
	print "High quality EQs... disabled"
else:
	print "High quality EQs... enabled"
	build_flags += 'hifieq '

#Experimental IPOD support
flags['ipod'] = util.get_flags(env, 'ipod', 0)
if int(flags['ipod']):
	env.Append(CPPDEFINES = '__IPOD__')

	if build.platform_is_windows:
		env.Append(LIBS = 'gpod');
		# You must check v-this-v directory out from http://publicsvn.songbirdnest.com/vendor-binaries/trunk/windows-i686-msvc8/libgpod/
		env.Append(LIBPATH='../../../windows-i686-msvc8/libgpod/release/lib')
		# Following building the following must be added to the dist folder in order for mixxx to run with ipod support on Windows
		# \windows-i686-msvc8\libgpod\release\lib\libgpod.dll
		# \windows-i686-msvc8\glib\release\bin\libgobject-2.0-0.dll
		# \windows-i686-msvc8\glib\release\bin\libglib-2.0-0.dll
		# \windows-i686-msvc8\libiconv\release\bin\iconv.dll
		# \windows-i686-msvc8\gettext\release\binintl.dll
	if build.platform_is_linux or build.platform_is_osx:
		# env.Append(LIBS = 'libgpod-1.0')
		# env.Append(LIBS = 'glib-2.0')
		env.ParseConfig('pkg-config libgpod-1.0 --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config glib-2.0 --silence-errors --cflags --libs')

	sources += Split("""wipodtracksmodel.cpp """) #IPOD
	print "iPod support... enabled"
	build_flags += 'ipod '
else:
	print "iPod support... disabled"

#Shoutcast support
flags_shoutcast = util.get_flags(env, 'shoutcast', 0)

if int(flags_shoutcast):
	shoutmp3 = 0
	shoutogg = 1
	if not libshout_found:
		print "libshout was not found! Please install it or compile Mixxx without Shoutcast support using the shoutcast=0 flag."
		Exit(1)

	env.Append(CPPDEFINES = '__SHOUTCAST__')
	if build.platform_is_windows:
		env.Append(LIBS = 'pthreadVC2')
		env.Append(LIBS = 'pthreadVCE2')
		env.Append(LIBS = 'pthreadVSE2')
	else:
		if not vorbisenc:
			#libvorbisenc does only exist on Linux and OSX, on Windows it is included in vorbisfile.dll
			print "libvorbisenc was not found! Please install it or compile Mixxx without Shoutcast support using the shoutcast=0 flag."
			Exit(1)

	sources += Split(""" dlgprefshoutcast.cpp engine/engineshoutcast.cpp recording/encodervorbis.cpp recording/encodermp3.cpp""" )
	build_flags += 'shoutcast '

	shoutmp3 = 1
	shoutogg = 1

	if shoutmp3 and shoutogg:
		print "Shoutcast support (OGG/MP3)... enabled"
	elif shoutmp3:
		print "Shoutcast support (MP3)... enabled"
	elif shoutogg:
		print "Shoutcast support (OGG)... enabled"
	else:
		print "Shoutcast support... enabled"

	env.Uic4('dlgprefshoutcastdlg.ui')

else:
	print "Shoutcast support... disabled"

#LADSPA
flags['ladspa'] = util.get_flags(env, 'ladspa', 0)
if int(flags['ladspa']):
	env.Append(CPPPATH=['#lib/ladspa']) #If you add more directories, separate them with a semicolon (;)
	env.Append(CPPDEFINES = '__LADSPA__')
	sources += Split("""engine/engineladspa.cpp
                            ladspa/ladspaloader.cpp
                            ladspa/ladspalibrary.cpp
                            ladspa/ladspaplugin.cpp
                            ladspa/ladspainstance.cpp
                            ladspa/ladspacontrol.cpp
                            ladspa/ladspainstancestereo.cpp
                            ladspa/ladspainstancemono.cpp
                            ladspaview.cpp
                            ladspa/ladspapreset.cpp
                            ladspa/ladspapresetmanager.cpp
                            ladspa/ladspapresetknob.cpp
                            ladspa/ladspapresetinstance.cpp
                            dlgladspa.cpp
                            ladspa/ladspapresetslot.cpp
                            """)
	plugins += SConscript(File('#lib/ladspa/SConscript'))
	env.Alias('plugins', plugins)
	print "LADSPA support... enabled"
	build_flags += 'ladspa '
else:
	print "LADSPA support... disabled"

#Vinyl Control
flags['vinylcontrol'] = util.get_flags(env, 'vinylcontrol', 1)
if int(flags['vinylcontrol']):
	env.Append(CPPDEFINES = '__VINYLCONTROL__')
	sources += Split(""" vinylcontrol.cpp vinylcontrolproxy.cpp vinylcontrolscratchlib.cpp vinylcontrolxwax.cpp dlgprefvinyl.cpp vinylcontrolsignalwidget.cpp engine/enginevinylcontrol.cpp """)
	env.Append(CPPPATH='#lib/xwax')
	if build.platform_is_windows:
		sources += Split("""#lib/xwax/timecoder_win32.c """)
	else:
		sources += Split("""#lib/xwax/timecoder.c """)
	env.Append(CPPPATH='#lib/scratchlib')
	sources += Split("""#lib/scratchlib/DAnalyse.cpp """)
	print "Vinyl Control... enabled"
	build_flags += 'vinylcontrol '
else:
	print "Vinyl Control... disabled"

flags['msvcdebug'] = util.get_flags(env, 'msvcdebug', 0)
if build.platform_is_windows:
        if not build.toolchain_is_msvs:
                print "Error, msvcdebug flag set when toolchain is not MSVS. Exiting."
                Exit(1)

	if int(flags['msvcdebug']):
		env.Append(CCFLAGS = '/MDd') # required for sndfile w/ flac support on windows
		env.Append(LINKFLAGS = '/DEBUG')
		if bitwidth == '64':
			env.Append(CXXFLAGS = '/Zi')
			env.Append(LINKFLAGS = '/NODEFAULTLIB:MSVCRT')
		else:
			env.Append(CXXFLAGS = '/ZI')
		print "MSVC Debugging... enabled"
		build_flags += 'msvcdebug '
	else:
		env.Append(LINKFLAGS = '/subsystem:windows')
		env.Append(CCFLAGS = '/MD') # required for sndfile w/ flac support on windows
		print "MSVC Debugging... disabled"


flags['tonal'] = util.get_flags(env, 'tonal', 0)
if int(flags['tonal']):
	print "Tonal analysis... enabled"
	build_flags += 'tonal '
	sources += Split("""tonal/FourierTransform.cxx tonal/Segmentation.cxx
			tonal/tonalanalyser.cpp tonal/ConstantQTransform.cxx
			tonal/ConstantQFolder.cxx""")
else:
	print "Tonal analysis... disabled"



flags['m4a'] = util.get_flags(env, 'm4a', 0)
if int(flags['m4a']):
	print "Apple M4A audio file support...",
	if have_m4a:
		print "enabled"

		# If the compile did not work, then enable the M4AHACK define.
		if have_faad_26:
			env.Append(CPPDEFINES = '__M4AHACK__')
			print "libfaad 2.6 compatibility mode... enabled"

		if have_mp4v2_h:
			env.Append(CPPDEFINES = '__MP4V2__')

	#	env.ParseConfig('pkg-config libmp4v2-dev --silence-errors --cflags --libs') # no pkg-config data for libmp4v2-dev
	#	FIXME: should do conf.CheckCHeader('mp4.h') or something...
		env.Append(CPPDEFINES = '__M4A__')
		build_flags += 'm4a '
		env.Append(LIBS = 'libmp4v2')
		env.Append(LIBS = 'libfaad')
	else:
		print "not found (did you install libmp4v2 and libfaad?)"
else:
	print "Apple M4A audio file support... disabled"



def build_gtest():
	gtest_dir = env.Dir("#lib/gtest-1.3.0")
	gtest_dir.addRepository(env.Dir('#lib/gtest-1.3.0'))
	#env['EXE_OUTPUT'] = '#/lib/gtest-1.3.0/bin'  # example, optional
	env['LIB_OUTPUT'] = '#/lib/gtest-1.3.0/lib'
	Export('env')
	env.SConscript(env.File('scons/SConscript', gtest_dir))

	env.Append(LIBPATH="#lib/gtest-1.3.0/lib")
	env.Append(LIBS = 'gtest')
	env.Append(CPPPATH="#lib/gtest-1.3.0/include")

def build_tests():
	test_sources = (Glob('test/*.cpp', strings=True) + [x for x in sources if x != "main.cpp"])
	env.Program(target='mixxx-test', source=test_sources)
	Command("../mixxx-test", "./mixxx-test", Copy("$TARGET", "$SOURCE"))

def run_tests():
	ret = Execute("./mixxx-test")
	if ret != 0:
		print "WARNING: Not all tests pass. See mixxx-test output."
		Exit(ret)

flags['test'] = util.get_flags(env, 'test', 0) or 'test' in BUILD_TARGETS

if int(flags['test']):
	print "Test suite... enabled"
	build_gtest()
	build_flags += 'test '
else:
	print "Test suite... disabled"

# Script Studio
flags['script'] = util.get_flags(env, 'script', 0)
if int(flags['script']):
	if build.platform_is_windows:
		env.Append(LIBS = 'QtScript4')
	elif build.platform_is_linux:
		env.Append(LIBS = 'QtScript')
	elif build.platform_is_osx:
		#XXX put in logic here to add a -framework QtScript
		#env.Append(
		pass
	print "MixxxScript Studio... enabled"

	build_flags += 'script '
	sources += Split("""script/scriptengine.cpp script/scriptcontrolqueue.cpp
			script/scriptstudio.cpp script/scriptrecorder.cpp
			script/playinterface.cpp script/macro.cpp
			script/scriptcontrolevent.cpp script/trackcontrolevent.cpp
			script/numbercontrolevent.cpp script/numberrecorder.cpp
			script/macrolist.cpp script/trackrecorder.cpp
			script/sdatetime.cpp script/signalrecorder.cpp
			script/macrolistitem.cpp script/qtscriptinterface.cpp""")
	env.Append(CPPPATH = '$QTDIR/include/QtScript')
	env.Append(CPPDEFINES = '__SCRIPT__')

	env.Uic4('script/scriptstudio.ui')
else:
	flags['script'] = 0
	print "MixxxScript Studio... disabled"

# MIDI Scripting
flags['midiscript'] = util.get_flags(env, 'midiscript', 0)
if int(flags['midiscript']):
	if build.platform_is_windows:
		env.Append(LIBS = 'QtScript4')
	elif build.platform_is_linux:
		env.Append(LIBS = 'QtScript')
	elif build.platform_is_osx:
		#XXX put in logic here to add a -framework QtScript
		#env.Append(
		pass
	print "MIDI Scripting... enabled"

	build_flags += 'midiscript '
	sources += Split("""midi/midiscriptengine.cpp""")
	env.Append(CPPPATH = '$QTDIR/include/QtScript')
	env.Append(CPPDEFINES = '__MIDISCRIPT__')
else:
	flags['midiscript'] = 0
	print "MIDI Scripting... disabled"

# Profiling and Optimization
flags['profiling'] = util.get_flags(env, 'profiling', 0)
if build.platform_is_linux:
	if int(flags['profiling']):
		env.Append(CCFLAGS = '-pg')
                # -pg is not a valid linkflag
		env.Append(LINKFLAGS = '-pg')
		print "gprof (Linux) profiling support... enabled"
		build_flags += 'profiling '
	else:
		print "gprof (Linux) profiling support... disabled"

if build.platform_is_osx:
	if int(flags['profiling']):
		env.Append(CCFLAGS = '-finstrument-functions')
		env.Append(LINKFLAGS = '-lSaturn')
		print "Saturn (OS X) profiling support... enabled"
		build_flags += 'profiling '
	else:
		print "profiling profiling support... disabled"

flags['tuned'] = util.get_flags(env, 'tuned', 0)
if int(flags['tuned']):
	if not build.toolchain_is_gnu:
		ccv = env['CCVERSION'].split('.')
		if int(ccv[0]) >= 4 and int(ccv[1]) >= 2:
                        # Should we use -mtune as well?
			env.Append(CCFLAGS = '-march=native')
                        # Doesn't make sense as a linkflag
			env.Append(LINKFLAGS = '-march=native')
			print "Optimizing for this CPU... yes"
			build_flags += 'tuned '
		else:
			print "Optimizing for this CPU... no (requires gcc >= 4.2.0)"
	elif build.toolchain_is_msvs:
		if bitwidth == '64':
			print "Optimizing for this CPU class (" + machine + ")... yes"
			env.Append(CXXFLAGS = '/favor:' + machine)
		else:
			print "Optimizing for this CPU... no (not supported on 32-bit MSVC)"
else:
	if bitwidth == '64':
		if 'makerelease' in COMMAND_LINE_TARGETS:
			print "Optimizing for this CPU class... no  (due to makerelease)"
			# AMD64 is for AMD CPUs, EM64T is for Intel x64 ones (as opposed to IA64 which uses a different compiler.)
			# For a release, we choose to have code run about the same on both
			env.Append(CXXFLAGS = '/favor:blend')

#Specific optimization
flags['optimize'] = util.get_flags(env, 'optimize', 1)
if int(flags['optimize']):
	if build.toolchain_is_msvs:
		if build.machine_is_64bit:
			env.Append(LINKFLAGS = '/MACHINE:X64')
		else:
			env.Append(LINKFLAGS = '/MACHINE:'+machine)
		if int(flags['msvcdebug']):
			print "Specific optimizations... DISABLED DUE TO DEBUG"
		else:
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Append(CXXFLAGS = '/GL /MP')
			env.Append(LINKFLAGS = '/LTCG:STATUS')
			if flags['optimize']=='1':
				print "  Maximize speed (/O2)"
				env.Append(CXXFLAGS = '/O2')
			elif flags['optimize'] >= '2':
				print "  Maximum optimizations (/Ox)"
				env.Append(CXXFLAGS = '/Ox')
			if not build.machine_is_64bit: # SSE and SSE2 are core instructions on x64
				if flags['optimize'] == '3':
					print "  SSE instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE')
				elif flags['optimize'] == '4':
					print "  SSE2 instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE2')
	else:
		if not int(flags['tuned']):
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Replace(CFLAGS = '') # replace CFLAGS and CXXFLAGS with our own optimizations.
			if flags['optimize']=='1':
				env.Replace(CXXFLAGS = '-O3')
			elif flags['optimize']=='2':
				print "  P4 MMX/SSE optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=pentium4 -mmmx -msse2 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='3':
				print "  Intel Core Solo/Duo optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=prescott -mmmx -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='4':
				print "  Intel Core 2 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=nocona -mmmx -msse3 -mfpmath=sse -ffast-math -funroll-loops')
			elif flags['optimize']=='5':
				print "  Athlon Athlon-4/XP/MP optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=athlon-4 -mmmx -msse -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='6':
				print "  Athlon K8/Opteron/AMD64 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8 -mmmx -msse2 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='7':
				print "  Athlon K8/Opteron/AMD64 + SSE3 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8-sse3 -mmmx -msse2 -msse3 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='8':
				print "  Generic SSE/SSE2/SSE3 optimizations enabled (Celeron D)."
				env.Replace(CXXFLAGS = '-O3 -mmmx -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Specific optimizations... disabled"

#Linking with ASMLIB
flags['asmlib'] = util.get_flags(env, 'asmlib', 0)
if int(flags['asmlib']):
	print "Agner Fog\'s ASMLIB (http://www.agner.org/optimize)... enabled"
	env.Append(LIBPATH='#/../asmlib')
	build_flags += 'asmlib '
	if build.platform_is_linux:
		env.Append(CXXFLAGS = '-fno-builtin')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = '":alibelf' + bitwidth + 'o.a"')
	elif build.platform_is_osx:
		env.Append(CXXFLAGS = '-fno-builtin')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = '":alibmac' + bitwidth + 'o.a"')
	elif build.platform_is_windows:
		env.Append(CXXFLAGS = '/Oi-')   #Use ASMLIB's functions instead of the compiler's
		env.Append(LIBS = 'alibcof' + bitwidth + 'o')
	env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Agner Fog\'s ASMLIB (http://www.agner.org/optimize)... disabled"

#Debugging output
flags['qdebug'] = util.get_flags(env, 'qdebug', 0)
if build.platform_is_windows:
	if int(flags['msvcdebug']):
		flags['qdebug'] = 1		# Turn general debugging flag on too if msvcdebug is specified

if int(flags['qdebug']):
	build_flags += 'qdebug '
	print "Debugging message output... enabled"
else:
	env.Append(CPPDEFINES = 'QT_NO_DEBUG_OUTPUT')
	print "Debugging message output... disabled"

#Visual Studio 2005 hacks (MSVS Express Edition users shouldn't enable this)
flags['msvshacks'] = util.get_flags(env, 'msvshacks', 0)
if int(flags['msvshacks']):
	env.Append(CPPDEFINES = '__MSVS2005__')
	print "MSVS 2005 hacks... enabled"
	build_flags += 'msvshacks '
else:
	print "MSVS 2005 hacks... disabled"

#force 32-bit compile on GCC
'''flags['force32'] = util.get_flags(env, 'force32', 0)
if int(flags['force32']):
	env.Append(CCFLAGS = '-m32')
	env.Append(CXXFLAGS = '-m32')
	env.Append(LINKFLAGS = '-m32')
	print "Force 32-bit GCC compile... enabled"
else:
	print "Force 32-bit GCC compile... disabled"
'''

#Case Metrics
if build.platform_is_windows or build.platform_is_linux:
	flags['cmetrics'] = util.get_flags(env, 'cmetrics', 1)
else:
	flags['cmetrics'] = util.get_flags(env, 'cmetrics', 0) # Off on OS X for now...
if int(flags['cmetrics']):
	env.Append(CPPDEFINES = '__C_METRICS__')
	if build.platform_is_windows:
		env.Append(LIBS = 'cmetrics')
	else:
		client = 'MIXXX'
		server = 'metrics.mixxx.org' # mixxx metrics collector
		Export('client server flags[\'force32\']')
		env.Append(CPPPATH='#lib/cmetrics')
		sources += SConscript('#lib/cmetrics/SConscript')
	print "Case Metrics profiling... enabled"
	build_flags += 'cmetrics '
else:
	print "Case Metrics profiling... disabled"

#env.Append(CPPDEFINES=[('BUILD_FLAGS', "'%s'" % build_flags)])

### Put flags info into a file
f = open("build.h","a")
try:
	f.write('#define BUILD_FLAGS "' + build_flags + '"\n')
finally:
	f.close()


#Tell SCons to build unit tests
if int(flags['test']):
	print "Building tests."
	build_tests()

if 'test' in BUILD_TARGETS:
	print "Running tests."
	run_tests()

#Set up the MSVC target to build a Visual Studio project/solution file
if 'msvc' in COMMAND_LINE_TARGETS:
	includes = map(str, Glob('#src/*.h'))
	includes += map(str, Glob('#src/visual/*.h'))
	#Make the project file aware of any command-line arguments that were passed...
	cmdargs = ""
	for k in SCons.Script.ARGUMENTS:
		cmdargs += " " + k + "=" + SCons.Script.ARGUMENTS[k]
	env.Append(MSVSSCONSFLAGS = cmdargs)
	#env.Append(MSVSSCONSFLAGS = ' qtdir=' + flags['qtdir'])

	# This is the right way to do it but scons is stupid and doesn't copy flags in... Adam
	# Set up environment for debug target
	# TODO Handle lib versions ie /MDd /Md etc...
	#debugenv = env.Clone()
	#debugenv.Prepend(LINKFLAGS = ['/DEBUG','/PDB:dist' + bitwidth + '/mixxx.pdb']) # Generate MS VC Program Debug Database
	#debugenv.Append(CXXFLAGS = '/ZI')

	msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Debug', runfile = '../dist' + bitwidth + '/mixxx.exe')

	# Reenable this once bug in scons is fixed...
	#msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Release', runfile = '../dist' + bitwidth + '/mixxx.exe')

	env.Alias('msvc', msvc)

# Print the build flags (useful if the flags have been cached, ie. if you just run "scons"
# and want to see the flags that you used last time)
print "================"
print "Building with flags: " + build_flags
print "================\n"

#Save the options to cache
vars.Save(cachefile, env)

Export('sources', 'flags')
