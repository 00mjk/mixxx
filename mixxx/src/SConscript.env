#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys, os, platform
import SCons.Script
import logging

from build import util, mixxx, depends

Import('build')
#Import('platform')
#Import('machine')	#CPU architecture for optimization
#Import('architecture')	#CPU type & binary format for optimization
#Import('bitwidth')      #CPU bit width that can be forced (use this for most build items)

# Checks for pkg-config on Linux
def CheckForPKGConfig( context, version='0.0.0' ):
	context.Message( "Checking for pkg-config (at least version %s)... " % version )
	ret = context.TryAction( "pkg-config --atleast-pkgconfig-version=%s" %version )[0]
	context.Result( ret )
	return ret

# Uses pkg-config to check for a minimum version
def CheckForPKG( context, name, version="" ):
	if version == "":
		context.Message( "Checking for %s... \t" % name )
		ret = context.TryAction( "pkg-config --exists '%s'" % name )[0]
	else:
		context.Message( "Checking for %s (%s or higher)... \t" % (name,version) )
		ret = context.TryAction( "pkg-config --atleast-version=%s '%s'" % (version,name) )[0]
		context.Result( ret )
	return ret

# Grab the created environment from the MixxxBuild
env = build.env

env['MIXXX_VERSION'] = util.get_mixxx_version() #should this be in the env?
env['CPPDEFINES'] = [''] #Initialize this as a list, fixes a bug where first CPPDEFINE would get mangled

#Figure out what architecture we are, set up bitwith and platform variables
arch_stuff = util.determine_architecture(build.platform, ARGUMENTS, env)
architecture = arch_stuff['architecture']
machine = arch_stuff["machine"]
bitwidth = arch_stuff["bitwidth"]
build_dir = util.get_build_dir(build.platform, bitwidth)

Export('architecture')
#So architecture-specific decisions & optimizations can be made in the SConscript
Export('machine')
Export('bitwidth')
Export('build_dir')

#Import environment variables from the terminal. Note that some variables
#correspond to variables inside the SCons env with different names,
# eg. the shell's "CFLAGS" ---> SCons' "CCFLAGS".
if os.environ.has_key('CC'):
	env['CC'] = os.environ['CC']
if os.environ.has_key('CFLAGS'):
	env['CCFLAGS'] += SCons.Util.CLVar(os.environ['CFLAGS'])
if os.environ.has_key('CXX'):
	env['CXX'] = os.environ['CXX']
if os.environ.has_key('CXXFLAGS'):
	env['CXXFLAGS'] += SCons.Util.CLVar(os.environ['CXXFLAGS'])
if os.environ.has_key('LDFLAGS'):
	env['LINKFLAGS'] += SCons.Util.CLVar(os.environ['LDFLAGS'])

#env.Append(CPPDEFINES=[('BUILD_REV', '"%s"' % getBZRRevision())]) #doing this forces a rebuild of everything whenever a commit happens -- not much fun
## instead, embed BZR version into build
## Put version info into a file, so it doesn't force a rebuild of everything :)
f = open("build.h","w")
try:
	f.write('#define BUILD_REV "' + util.get_bzr_revision() + '"\n')
finally:
	f.close()

#Check for dependencies if we're not doing a clean...
#if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig,
                                       'CheckForPKG' : CheckForPKG })

available_features = [depends.MixxxCore]
extra_features = build.get_features()
available_features.extend(extra_features)

# Instantiate the features
available_features = [feature_class() for feature_class in available_features]

visited_dependencies = set()
active_dependencies = []
unmet_dependencies = False

def visit_dependency(dependency_class, build, conf):
        """Recursively configure all dependencies. Skip over dependencies we
        have already setup."""

        if dependency_class in visited_dependencies:
                return
        visited_dependencies.add(dependency_class)
        dependency = dependency_class()

        try:
                print "Configuring %s" % dependency.name
                dependency.configure(build, conf)
        except Exception, e:
                logging.error("Unmet dependency: %s" % e)
                unmet_dependencies = True
        active_dependencies.append(dependency)

        for sub_dependency in dependency.depends(build):
                visit_dependency(sub_dependency, build, conf)

for feature in available_features:
        try:
                print "Configuring %s" % feature.name
                feature.configure(build, conf)

                # Only process the feature's dependencies if it's enabled
                if feature.enabled(build):
                        active_dependencies.append(feature)
                        for dependency in feature.depends(build):
                                visit_dependency(dependency, build, conf)
        except Exception, e:
                logging.error("Unmet dependency: %s" % e)
                unmet_dependencies = True

if unmet_dependencies:
        logging.error("Build had unmet dependencies. Exiting.")
        Exit(1)

sources = []
flags = build.flags

# Query each active dependency for sources they require
for dependency in active_dependencies:
        dep_sources = dependency.sources(build)
        if dep_sources is not None:
                sources.extend(dep_sources)

env = conf.Finish()

#declare platform specific flags? though we shouldn't really need these, the compilers should Just Know...
#on __APPLE__ it works like that. probably we just need to look into what the default __platform__ #defines are and search and replace in the code
env.Append(CPPDEFINES=machine)

#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

#Parse command-line build flags
build_flags = ""

print "\nFeatures Summary:\n================"

for feature in available_features:
        print "%060s... %s" % (feature.description(),
                               "Enabled" if feature.enabled(build) else "Disabled")

build_flags = ' '.join(sorted([k for k,v in build.flags.items() if int(v) > 0]))

def build_tests():
	test_sources = (Glob('test/*.cpp', strings=True) + [x for x in sources if x != "main.cpp"])
	env.Program(target='mixxx-test', source=test_sources)
	Command("../mixxx-test", "./mixxx-test", Copy("$TARGET", "$SOURCE"))

def run_tests(self):
        ret = Execute("./mixxx-test")
	if ret != 0:
                print "WARNING: Not all tests pass. See mixxx-test output."
                Exit(ret)

flags['tuned'] = util.get_flags(env, 'tuned', 0)
if int(flags['tuned']):
	if not build.toolchain_is_gnu:
		ccv = env['CCVERSION'].split('.')
		if int(ccv[0]) >= 4 and int(ccv[1]) >= 2:
                        # Should we use -mtune as well?
			env.Append(CCFLAGS = '-march=native')
                        # Doesn't make sense as a linkflag
			env.Append(LINKFLAGS = '-march=native')
			print "Optimizing for this CPU... yes"
			build_flags += 'tuned '
		else:
			print "Optimizing for this CPU... no (requires gcc >= 4.2.0)"
	elif build.toolchain_is_msvs:
		if bitwidth == '64':
			print "Optimizing for this CPU class (" + machine + ")... yes"
			env.Append(CXXFLAGS = '/favor:' + machine)
		else:
			print "Optimizing for this CPU... no (not supported on 32-bit MSVC)"
else:
	if bitwidth == '64':
		if 'makerelease' in COMMAND_LINE_TARGETS:
			print "Optimizing for this CPU class... no  (due to makerelease)"
			# AMD64 is for AMD CPUs, EM64T is for Intel x64 ones (as opposed to IA64 which uses a different compiler.)
			# For a release, we choose to have code run about the same on both
			env.Append(CXXFLAGS = '/favor:blend')

#Specific optimization
flags['optimize'] = util.get_flags(env, 'optimize', 1)
if int(flags['optimize']):
	if build.toolchain_is_msvs:
		if build.machine_is_64bit:
			env.Append(LINKFLAGS = '/MACHINE:X64')
		else:
			env.Append(LINKFLAGS = '/MACHINE:'+machine)
		if int(flags['msvcdebug']):
			print "Specific optimizations... DISABLED DUE TO DEBUG"
		else:
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Append(CXXFLAGS = '/GL /MP')
			env.Append(LINKFLAGS = '/LTCG:STATUS')
			if flags['optimize']=='1':
				print "  Maximize speed (/O2)"
				env.Append(CXXFLAGS = '/O2')
			elif flags['optimize'] >= '2':
				print "  Maximum optimizations (/Ox)"
				env.Append(CXXFLAGS = '/Ox')
			if not build.machine_is_64bit: # SSE and SSE2 are core instructions on x64
				if flags['optimize'] == '3':
					print "  SSE instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE')
				elif flags['optimize'] == '4':
					print "  SSE2 instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE2')
	else:
		if not int(flags['tuned']):
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags['optimize']) + ' '
			env.Replace(CFLAGS = '') # replace CFLAGS and CXXFLAGS with our own optimizations.
			if flags['optimize']=='1':
				env.Replace(CXXFLAGS = '-O3')
			elif flags['optimize']=='2':
				print "  P4 MMX/SSE optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=pentium4 -mmmx -msse2 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='3':
				print "  Intel Core Solo/Duo optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=prescott -mmmx -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='4':
				print "  Intel Core 2 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=nocona -mmmx -msse3 -mfpmath=sse -ffast-math -funroll-loops')
			elif flags['optimize']=='5':
				print "  Athlon Athlon-4/XP/MP optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=athlon-4 -mmmx -msse -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='6':
				print "  Athlon K8/Opteron/AMD64 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8 -mmmx -msse2 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='7':
				print "  Athlon K8/Opteron/AMD64 + SSE3 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8-sse3 -mmmx -msse2 -msse3 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags['optimize']=='8':
				print "  Generic SSE/SSE2/SSE3 optimizations enabled (Celeron D)."
				env.Replace(CXXFLAGS = '-O3 -mmmx -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Specific optimizations... disabled"

#force 32-bit compile on GCC
'''flags['force32'] = util.get_flags(env, 'force32', 0)
if int(flags['force32']):
	env.Append(CCFLAGS = '-m32')
	env.Append(CXXFLAGS = '-m32')
	env.Append(LINKFLAGS = '-m32')
	print "Force 32-bit GCC compile... enabled"
else:
	print "Force 32-bit GCC compile... disabled"
'''

### Put flags info into a file
f = open("build.h","a")
try:
	f.write('#define BUILD_FLAGS "' + build_flags + '"\n')
finally:
	f.close()

#Tell SCons to build unit tests
if int(flags['test']):
	print "Building tests."
	build_tests()

if 'test' in BUILD_TARGETS:
	print "Running tests."
	run_tests()

#Set up the MSVC target to build a Visual Studio project/solution file
if 'msvc' in COMMAND_LINE_TARGETS:
	includes = map(str, Glob('#src/*.h'))
	includes += map(str, Glob('#src/visual/*.h'))
	#Make the project file aware of any command-line arguments that were passed...
	cmdargs = ""
	for k in SCons.Script.ARGUMENTS:
		cmdargs += " " + k + "=" + SCons.Script.ARGUMENTS[k]
	env.Append(MSVSSCONSFLAGS = cmdargs)
	#env.Append(MSVSSCONSFLAGS = ' qtdir=' + flags['qtdir'])

	# This is the right way to do it but scons is stupid and doesn't copy flags in... Adam
	# Set up environment for debug target
	# TODO Handle lib versions ie /MDd /Md etc...
	#debugenv = env.Clone()
	#debugenv.Prepend(LINKFLAGS = ['/DEBUG','/PDB:dist' + bitwidth + '/mixxx.pdb']) # Generate MS VC Program Debug Database
	#debugenv.Append(CXXFLAGS = '/ZI')

	msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Debug', runfile = '../dist' + bitwidth + '/mixxx.exe')

	# Reenable this once bug in scons is fixed...
	#msvc = env.MSVSProject(target = 'mixxx' + env['MSVSPROJECTSUFFIX'], srcs = sources, incs = includes, variant = 'Release', runfile = '../dist' + bitwidth + '/mixxx.exe')

	env.Alias('msvc', msvc)

# Print the build flags (useful if the flags have been cached, ie. if you just run "scons"
# and want to see the flags that you used last time)
print "================"
print "Building with flags: " + build_flags
print "Building with CCFLAGS: " + env['CCFLAGS']
print "Building with CPPDEFINES: " + ' '.join(['-D'+'='.join(pair) if not isinstance(pair, basestring) else '-D'+pair for pair in env['CPPDEFINES']])
print "Building with CXXFLAGS: " + env['CXXFLAGS']
print "Building with LINKFLAGS: " + env['LINKFLAGS']
print "Building with LIBS: " + ' '.join(env['LIBS'])
print "================\n"

Export('sources', 'flags')
