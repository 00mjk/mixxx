// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/beats.proto

#ifndef PROTOBUF_proto_2fbeats_2eproto__INCLUDED
#define PROTOBUF_proto_2fbeats_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mixxx {
namespace track {
namespace io {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fbeats_2eproto();
void protobuf_AssignDesc_proto_2fbeats_2eproto();
void protobuf_ShutdownFile_proto_2fbeats_2eproto();

class Beat;
class Bpm;
class BeatMap;
class BeatGrid;

enum Source {
  ANALYSER = 0,
  FILE_METADATA = 1,
  USER = 2
};
bool Source_IsValid(int value);
const Source Source_MIN = ANALYSER;
const Source Source_MAX = USER;
const int Source_ARRAYSIZE = Source_MAX + 1;

// ===================================================================

class Beat : public ::google::protobuf::MessageLite {
 public:
  Beat();
  virtual ~Beat();
  
  Beat(const Beat& from);
  
  inline Beat& operator=(const Beat& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Beat& default_instance();
  
  void Swap(Beat* other);
  
  // implements Message ----------------------------------------------
  
  Beat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Beat& from);
  void MergeFrom(const Beat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 frame_position = 1;
  inline bool has_frame_position() const;
  inline void clear_frame_position();
  static const int kFramePositionFieldNumber = 1;
  inline ::google::protobuf::int32 frame_position() const;
  inline void set_frame_position(::google::protobuf::int32 value);
  
  // optional bool enabled = 2 [default = true];
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);
  
  // optional .mixxx.track.io.Source source = 3 [default = ANALYSER];
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline mixxx::track::io::Source source() const;
  inline void set_source(mixxx::track::io::Source value);
  
  // @@protoc_insertion_point(class_scope:mixxx.track.io.Beat)
 private:
  inline void set_has_frame_position();
  inline void clear_has_frame_position();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_source();
  inline void clear_has_source();
  
  ::google::protobuf::int32 frame_position_;
  bool enabled_;
  int source_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fbeats_2eproto();
  friend void protobuf_AssignDesc_proto_2fbeats_2eproto();
  friend void protobuf_ShutdownFile_proto_2fbeats_2eproto();
  
  void InitAsDefaultInstance();
  static Beat* default_instance_;
};
// -------------------------------------------------------------------

class Bpm : public ::google::protobuf::MessageLite {
 public:
  Bpm();
  virtual ~Bpm();
  
  Bpm(const Bpm& from);
  
  inline Bpm& operator=(const Bpm& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const Bpm& default_instance();
  
  void Swap(Bpm* other);
  
  // implements Message ----------------------------------------------
  
  Bpm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Bpm& from);
  void MergeFrom(const Bpm& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double bpm = 1;
  inline bool has_bpm() const;
  inline void clear_bpm();
  static const int kBpmFieldNumber = 1;
  inline double bpm() const;
  inline void set_bpm(double value);
  
  // optional .mixxx.track.io.Source source = 2 [default = ANALYSER];
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 2;
  inline mixxx::track::io::Source source() const;
  inline void set_source(mixxx::track::io::Source value);
  
  // @@protoc_insertion_point(class_scope:mixxx.track.io.Bpm)
 private:
  inline void set_has_bpm();
  inline void clear_has_bpm();
  inline void set_has_source();
  inline void clear_has_source();
  
  double bpm_;
  int source_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fbeats_2eproto();
  friend void protobuf_AssignDesc_proto_2fbeats_2eproto();
  friend void protobuf_ShutdownFile_proto_2fbeats_2eproto();
  
  void InitAsDefaultInstance();
  static Bpm* default_instance_;
};
// -------------------------------------------------------------------

class BeatMap : public ::google::protobuf::MessageLite {
 public:
  BeatMap();
  virtual ~BeatMap();
  
  BeatMap(const BeatMap& from);
  
  inline BeatMap& operator=(const BeatMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BeatMap& default_instance();
  
  void Swap(BeatMap* other);
  
  // implements Message ----------------------------------------------
  
  BeatMap* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BeatMap& from);
  void MergeFrom(const BeatMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .mixxx.track.io.Beat beat = 1;
  inline int beat_size() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 1;
  inline const ::mixxx::track::io::Beat& beat(int index) const;
  inline ::mixxx::track::io::Beat* mutable_beat(int index);
  inline ::mixxx::track::io::Beat* add_beat();
  inline const ::google::protobuf::RepeatedPtrField< ::mixxx::track::io::Beat >&
      beat() const;
  inline ::google::protobuf::RepeatedPtrField< ::mixxx::track::io::Beat >*
      mutable_beat();
  
  // @@protoc_insertion_point(class_scope:mixxx.track.io.BeatMap)
 private:
  
  ::google::protobuf::RepeatedPtrField< ::mixxx::track::io::Beat > beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fbeats_2eproto();
  friend void protobuf_AssignDesc_proto_2fbeats_2eproto();
  friend void protobuf_ShutdownFile_proto_2fbeats_2eproto();
  
  void InitAsDefaultInstance();
  static BeatMap* default_instance_;
};
// -------------------------------------------------------------------

class BeatGrid : public ::google::protobuf::MessageLite {
 public:
  BeatGrid();
  virtual ~BeatGrid();
  
  BeatGrid(const BeatGrid& from);
  
  inline BeatGrid& operator=(const BeatGrid& from) {
    CopyFrom(from);
    return *this;
  }
  
  static const BeatGrid& default_instance();
  
  void Swap(BeatGrid* other);
  
  // implements Message ----------------------------------------------
  
  BeatGrid* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BeatGrid& from);
  void MergeFrom(const BeatGrid& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::std::string GetTypeName() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .mixxx.track.io.Bpm bpm = 1;
  inline bool has_bpm() const;
  inline void clear_bpm();
  static const int kBpmFieldNumber = 1;
  inline const ::mixxx::track::io::Bpm& bpm() const;
  inline ::mixxx::track::io::Bpm* mutable_bpm();
  inline ::mixxx::track::io::Bpm* release_bpm();
  
  // optional .mixxx.track.io.Beat first_beat = 2;
  inline bool has_first_beat() const;
  inline void clear_first_beat();
  static const int kFirstBeatFieldNumber = 2;
  inline const ::mixxx::track::io::Beat& first_beat() const;
  inline ::mixxx::track::io::Beat* mutable_first_beat();
  inline ::mixxx::track::io::Beat* release_first_beat();
  
  // @@protoc_insertion_point(class_scope:mixxx.track.io.BeatGrid)
 private:
  inline void set_has_bpm();
  inline void clear_has_bpm();
  inline void set_has_first_beat();
  inline void clear_has_first_beat();
  
  ::mixxx::track::io::Bpm* bpm_;
  ::mixxx::track::io::Beat* first_beat_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_proto_2fbeats_2eproto();
  friend void protobuf_AssignDesc_proto_2fbeats_2eproto();
  friend void protobuf_ShutdownFile_proto_2fbeats_2eproto();
  
  void InitAsDefaultInstance();
  static BeatGrid* default_instance_;
};
// ===================================================================


// ===================================================================

// Beat

// optional int32 frame_position = 1;
inline bool Beat::has_frame_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Beat::set_has_frame_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Beat::clear_has_frame_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Beat::clear_frame_position() {
  frame_position_ = 0;
  clear_has_frame_position();
}
inline ::google::protobuf::int32 Beat::frame_position() const {
  return frame_position_;
}
inline void Beat::set_frame_position(::google::protobuf::int32 value) {
  set_has_frame_position();
  frame_position_ = value;
}

// optional bool enabled = 2 [default = true];
inline bool Beat::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Beat::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Beat::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Beat::clear_enabled() {
  enabled_ = true;
  clear_has_enabled();
}
inline bool Beat::enabled() const {
  return enabled_;
}
inline void Beat::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional .mixxx.track.io.Source source = 3 [default = ANALYSER];
inline bool Beat::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Beat::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Beat::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Beat::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline mixxx::track::io::Source Beat::source() const {
  return static_cast< mixxx::track::io::Source >(source_);
}
inline void Beat::set_source(mixxx::track::io::Source value) {
  GOOGLE_DCHECK(mixxx::track::io::Source_IsValid(value));
  set_has_source();
  source_ = value;
}

// -------------------------------------------------------------------

// Bpm

// optional double bpm = 1;
inline bool Bpm::has_bpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bpm::set_has_bpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bpm::clear_has_bpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bpm::clear_bpm() {
  bpm_ = 0;
  clear_has_bpm();
}
inline double Bpm::bpm() const {
  return bpm_;
}
inline void Bpm::set_bpm(double value) {
  set_has_bpm();
  bpm_ = value;
}

// optional .mixxx.track.io.Source source = 2 [default = ANALYSER];
inline bool Bpm::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bpm::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bpm::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bpm::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline mixxx::track::io::Source Bpm::source() const {
  return static_cast< mixxx::track::io::Source >(source_);
}
inline void Bpm::set_source(mixxx::track::io::Source value) {
  GOOGLE_DCHECK(mixxx::track::io::Source_IsValid(value));
  set_has_source();
  source_ = value;
}

// -------------------------------------------------------------------

// BeatMap

// repeated .mixxx.track.io.Beat beat = 1;
inline int BeatMap::beat_size() const {
  return beat_.size();
}
inline void BeatMap::clear_beat() {
  beat_.Clear();
}
inline const ::mixxx::track::io::Beat& BeatMap::beat(int index) const {
  return beat_.Get(index);
}
inline ::mixxx::track::io::Beat* BeatMap::mutable_beat(int index) {
  return beat_.Mutable(index);
}
inline ::mixxx::track::io::Beat* BeatMap::add_beat() {
  return beat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mixxx::track::io::Beat >&
BeatMap::beat() const {
  return beat_;
}
inline ::google::protobuf::RepeatedPtrField< ::mixxx::track::io::Beat >*
BeatMap::mutable_beat() {
  return &beat_;
}

// -------------------------------------------------------------------

// BeatGrid

// optional .mixxx.track.io.Bpm bpm = 1;
inline bool BeatGrid::has_bpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeatGrid::set_has_bpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BeatGrid::clear_has_bpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BeatGrid::clear_bpm() {
  if (bpm_ != NULL) bpm_->::mixxx::track::io::Bpm::Clear();
  clear_has_bpm();
}
inline const ::mixxx::track::io::Bpm& BeatGrid::bpm() const {
  return bpm_ != NULL ? *bpm_ : *default_instance_->bpm_;
}
inline ::mixxx::track::io::Bpm* BeatGrid::mutable_bpm() {
  set_has_bpm();
  if (bpm_ == NULL) bpm_ = new ::mixxx::track::io::Bpm;
  return bpm_;
}
inline ::mixxx::track::io::Bpm* BeatGrid::release_bpm() {
  clear_has_bpm();
  ::mixxx::track::io::Bpm* temp = bpm_;
  bpm_ = NULL;
  return temp;
}

// optional .mixxx.track.io.Beat first_beat = 2;
inline bool BeatGrid::has_first_beat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BeatGrid::set_has_first_beat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BeatGrid::clear_has_first_beat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BeatGrid::clear_first_beat() {
  if (first_beat_ != NULL) first_beat_->::mixxx::track::io::Beat::Clear();
  clear_has_first_beat();
}
inline const ::mixxx::track::io::Beat& BeatGrid::first_beat() const {
  return first_beat_ != NULL ? *first_beat_ : *default_instance_->first_beat_;
}
inline ::mixxx::track::io::Beat* BeatGrid::mutable_first_beat() {
  set_has_first_beat();
  if (first_beat_ == NULL) first_beat_ = new ::mixxx::track::io::Beat;
  return first_beat_;
}
inline ::mixxx::track::io::Beat* BeatGrid::release_first_beat() {
  clear_has_first_beat();
  ::mixxx::track::io::Beat* temp = first_beat_;
  first_beat_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace io
}  // namespace track
}  // namespace mixxx

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fbeats_2eproto__INCLUDED
