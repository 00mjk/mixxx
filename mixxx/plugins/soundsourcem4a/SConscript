#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import SCons
import shutil

#TODO:
#-figure out what files actually need what defines and write separate builder lines for them (so that changing a #define doesn't cause a rebuild of everything)
#-
#-

# BIG FAT WARNING:
# Make sure you use TABS for indentation, NOT spaces! (Python likes spaces well enough, but would much prefer to share tea time with tabs)
#
#   ####       ####  ##########  #####    #####  #####    #####  #####    #####
#   ######   ######     ####      #####  #####    #####  #####    #####  #####
#   #### ## ## ####     ####        ########        ########        ########
#   ####   #   ####     ####      #####  #####    #####  #####    #####  #####
#   ####       ####  ##########  #####    #####  #####    #####  #####    #####
#
#  #############################################################################
#    #########################################################################
#

#
#Useful functions
#

print "WE ARE IN:", os.getcwd()

plugins = []

def getSVNRevision(): # GPL code taken from http://trac.zeitherrschaft.org/zzub/browser/trunk/SConstruct
	# if this is a repository, take the string from svnversion
	svnversionpath = env.WhereIs('svnversion', os.environ['PATH'])
	if os.path.isdir('../.svn') and (svnversionpath != None):  # we always start in .obj for some reason, so we must use ../.svn
		rev = os.popen('svnversion ..').readline().strip()
		if rev != "" and rev != "exported":
			return rev
	return ""

def getBZRRevision():
	return os.popen("bzr revno").readline().strip()

def getMixxxVersion():
	version = 1.0
	return version


# Checks for pkg-config on Linux
def CheckForPKGConfig( context, version='0.0.0' ):
	context.Message( "Checking for pkg-config (at least version %s)... " % version )
	ret = context.TryAction( "pkg-config --atleast-pkgconfig-version=%s" %version )[0]
	context.Result( ret )
	return ret

# Uses pkg-config to check for a minimum version
def CheckForPKG( context, name, version="" ):
	if version == "":
		context.Message( "Checking for %s... \t" % name )
		ret = context.TryAction( "pkg-config --exists '%s'" % name )[0]
	else:
		context.Message( "Checking for %s (%s or higher)... \t" % (name,version) )
		ret = context.TryAction( "pkg-config --atleast-version=%s '%s'" % (version,name) )[0]
		context.Result( ret )
	return ret

def getFlags(env, argflag, default=0):
	"""
	* get value passed as an argument to scons as argflag=value
	* if no value is passed to scons use stored value
	* if no value is stored, use default
	Returns the value and stores it in env[argflag]
	"""
	flags = ARGUMENTS.get(argflag, -1)
	if int(flags) < 0:
		if env.has_key(argflag):
			flags = env[argflag]
		else: #default value
			flags = default
	env[argflag] = flags
	return flags

###### MAIN LINE ######
#######################


Import('platform')
Import('machine')	#CPU architecture for optimization
Import('architecture')	#CPU type & binary format for optimization

#Figure out what the QT path is


default_qtdir = {'linux': '/usr/share/qt4',
		 'bsd': '/usr/local/lib/qt4',
		 'osx': '/usr/lib/Qt-4.5', #XXX this should be smarter, we just need qt4 so we should accept the highest version that matches /usr/lib/Qt-4.*.*/
		 'win32': 'C:\\qt\\4.5.1',
		 'win64': 'C:\\qt\\4.5.1'}[platform]	 #ditto

#Read the qtdir flag, if it was set explicitly
flags_qtdir = ARGUMENTS.get('qtdir', os.environ.get('QTDIR', default_qtdir)) #environ['QTDIR'] there is mainly for the benefit of MSVC
if not os.path.exists(flags_qtdir):
	print "Error: QT path does not exist or QT4 is not installed."
	print "Please specify your QT path by running 'scons qtdir=[path]'"
	Exit(1)
elif flags_qtdir.find("qt3") != -1 or flags_qtdir.find("qt/3") != -1:
	print "Error: Mixxx now requires QT4 instead of QT3 - please use your QT4 path with the qtdir build flag."
	Exit(1)
else:
	print "QT path: " + flags_qtdir



#Set up our environment, tell SCONS to use its QT tools, and set some enviroment variables for it.
#The ENV = os.environ part pulls in your existing environment variables. This is useful for awkward Linux setups
#and on Windows where all the paths are set in the shell.
if platform in ('linux', 'bsd'):
	env = Environment(tools=['default','qt4'], toolpath=['#build/'], QTDIR=flags_qtdir, ENV = os.environ)
	#Whoever hacked this in, it breaks scons for people who've set PKG_CONFIG_PATH in their shell. - Albert
 	#os.environ['PKG_CONFIG_PATH']=flags_qtdir+'lib/pkgconfig'  #Set the PKG_CONFIG_PATH explicitly, handles multiple QT 4.x installations
elif platform == 'osx':
	env = Environment(tools=['default', 'qt4', 'OSConsX'], toolpath=['#build/', '#build/osx/'], ENV = os.environ)
elif 'win' in platform:
	#Pull in the environment's variables for win32...
	env = Environment(tools=['default','qt4', 'msvs'], toolpath=['#build/'], QTDIR=flags_qtdir, QT_LIB='', VCINSTALLDIR = os.getenv('VCInstallDir'), ENV = os.environ)
else:
	raise Exception("Unknown platform, didn't make a env variable. Crashing")

env['MIXXX_VERSION'] = getMixxxVersion() #should this be in the env?
env['CPPDEFINES'] = [''] #Initialize this as a list, fixes a bug where first CPPDEFINE would get mangled

## Global cache directory
## Put all project files in it so a rm -rf cache will clean up the config
if not env.has_key('CACHEDIR'):
	env['CACHEDIR'] = str(Dir('#cache/'))
if not os.path.isdir(env['CACHEDIR']):
	os.mkdir(env['CACHEDIR'])

## Avoid spreading .sconsign files everywhere
#env.SConsignFile(env['CACHEDIR']+'/scons_signatures')
## WARNING - We found that the above line causes SCons to randomly not find
##           dependencies for some reason. It might not happen right away, but
##           a good number of users found that it caused weird problems - Albert (May 15/08)


#Hijack scons -h and --help
cachefile = str(env['CACHEDIR']) + 'custom.py'
#opts = Options(cachefile)
vars = Variables(cachefile)
vars.Add('prefix', 'Set to your install prefix', '/usr/local')
vars.Add('qtdir', 'Set to your QT4 directory', '/usr/share/qt4')
vars.Add('hifieq', 'Set to 1 to enable high quality EQs', 1)
vars.Add('ipod', 'Set to 1 to enable iPod support through libgpod', 0)
vars.Add('ladspa', '(EXPERIMENTAL) Set to 1 to enable LADSPA plugin support', 1)
vars.Add('ffmpeg', '(EXPERIMENTAL) Set to 1 to enable FFMPEG support', 0)
vars.Add('vinylcontrol', 'Set to 1 to enable vinyl control support', 1)
vars.Add('shoutcast', 'Set to 1 to enable shoutcast support', 0)
vars.Add('cmetrics', 'Set to 1 to enable crash reporting/usage statistics via Case Metrics (This should be disabled on development builds)', 0)
vars.Add('asmlib','(EXPERIMENTAL) Set to 1 to enable linking against Agner Fog\'s hand-optimized asmlib, found at http://www.agner.org/optimize/', 0)
vars.Add('script', 'Set to 1 to enable MixxxScript/QtScript Studio support.', 0)
vars.Add('midiscript', 'Set to 1 to enable MIDI Scripting support.', 1)
vars.Add('tonal', 'Set to 1 to enable tonal analysis', 0)
vars.Add('m4a','Set to 1 to enable support for M4A audio (Apple non-drm''d music format)', 1)
vars.Add('qdebug', 'Set to 1 to enable verbose console debug output.', 1)
vars.Add('test', 'Set to 1 to build Mixxx test fixtures.', 0)
if not 'win' in platform:
	vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU (overrides "optimize")', 0)
	vars.Add('optimize', 'Set to:\n  1 for -O3 compiler optimizations\n  2 for Pentium 4 optimizations\n  3 for Intel Core optimizations\n  4 for Intel Core 2 optimizations\n  5 for Athlon-4/XP/MP optimizations\n  6 for K8/Opteron/AMD64 optimizations\n  7 for K8/Opteron/AMD64 w/ SSE3\n  8 for Celeron D (generic SSE/SSE2/SSE3) optimizations.', 1)
	vars.Add('gprof', '(DEVELOPER) Set to 1 to enable profiling using gprof', 0)
	vars.Add('force32', 'Set to 1 to force GCC to compile a 32-bit binary with the -m32 flag', 0)
else:
	if platform == 'win64':
		vars.Add('tuned', 'Set to 1 to optimize mixxx for this CPU class', 0)
	vars.Add('optimize', 'Set to:\n  1 to maximize speed (/O2)\n  2 for maximum optimizations (/Ox)\n  3 to use SSE code\n  4 to use SSE2 code.', 1)
	vars.Add('msvshacks', 'Set to 1 to build properly with MS Visual Studio 2005 (Express users should leave this off)', 0)
	vars.Add('msvcdebug', 'Set to 1 to link against MS libraries with debugging info (implies debug=1)', 0)
#env = Environment(options = opts)
vars.Update(env)
Help(vars.GenerateHelpText(env))

for getenv in ['CXXFLAGS', 'CCFLAGS', 'LINKFLAGS', 'LIBPATH', 'CPPPATH']:
	kwargs = {}
	if os.environ.has_key(getenv):
		kwargs[getenv] = SCons.Util.CLVar( os.environ[getenv] )
		env.Append(**kwargs)

#env.Append(CPPDEFINES=[('BUILD_REV', '"%s"' % getBZRRevision())]) #doing this forces a rebuild of everything whenever a commit happens -- not much fun
## instead, embed BZR version into build
## Put version info into a file, so it doesn't force a rebuild of everything :)
f = open("build.h","w")
try:
	f.write('#define BUILD_REV "' + getBZRRevision() + '"\n')
finally:
	f.close()

### embed SVN version into build
### Put version info into a file, so it doesn't force a rebuild of everything :)
#f = open("#.mixxx_version.h","w")
#try:
#	f.write('#define BUILD_REV "' + getSVNRevision() + '"\n')
#finally:
#	f.close()

#Mixxx sources to build
#sources = []
sources = Split("""  #src/soundsource.cpp """) # Still have to build soundsource.o into this file because we're subclassing????
#                    #src/trackinfoobject.cpp
#                    #src/soundsource.cpp
#                    #src/xmlparse.cpp
#                    #src/library/dao/cue.cpp
#                    #src/soundsourceproxy.cpp """)

#Set up the library path on Windows:
if platform == 'win64':
	env.Append(CPPPATH='#/../mixxx-win64lib-msvc') #If you add more directories, separate them with a semicolon (;)
	env.Append(LIBPATH='#/../mixxx-win64lib-msvc')

if platform == 'win32':
	env.Append(CPPPATH='#/../mixxx-win32lib-msvc') #If you add more directories, separate them with a semicolon (;)
	env.Append(LIBPATH='#/../mixxx-win32lib-msvc')

if 'win' in platform:
	env.Append(CPPPATH='../../lib/ladspa') #If you add more directories, separate them with a semicolon (;)
	env.Append(LINKFLAGS = ['/nodefaultlib:libc.lib', '/nodefaultlib:libcd.lib'])     #'/entry:mainCRTStartup']) #Don't want mainCRTStartup for the M4A DLL
	env.Append(LIBS='advapi32') # needed for PortMIDI
#'/subsystem:windows',

if platform == 'bsd':
	env.Append(CPPPATH=['/usr/include', '/usr/local/include', '/usr/X11R6/include/'])
	env.Append(LIBPATH=['/usr/lib/', '/usr/local/lib', '/usr/X11R6/lib'])
#BSD hacks
#XXX todo: move these into their proper places

	env.Append(LIBS='pthread')
	env.Append(LIBS=['ogg', 'vorbis']) #why do we need to do this on OpenBSD and not on Linux? if we don't then CheckLib("vorbisfile") fails
elif platform == 'osx':
	#Non-standard libpaths for fink and certain (most?) darwin ports
	env.Append(LIBPATH = ['/sw/lib'])
	env.Append(CPPPATH = ['/sw/include'])

	#Non-standard libpaths for darwin ports
	env.Append(LIBPATH = ['/opt/local/lib'])
	env.Append(CPPPATH = ['/opt/local/include'])


#Check for dependencies if we're not doing a clean...
#if not env.GetOption('clean') and not SCons.Util.containsAny(os.sys.argv, ['-h', '--help']):
conf = Configure(env, custom_tests = { 'CheckForPKGConfig' : CheckForPKGConfig, 'CheckForPKG' : CheckForPKG })

#TODO: Add all of the other configure checks as custom_tests properly.

# On Posix default SCons.LIBPREFIX = 'lib', on Windows default SCons.LIBPREFIX = ''

#hack: check for these here, before conf.Finish happens
have_mp4v2_h = conf.CheckHeader('mp4v2/mp4v2.h')
have_mp4 = (have_mp4v2_h and conf.CheckLib(['mp4v2', 'libmp4v2'])) or conf.CheckLib('mp4')

# We have to check for libfaad version 2.6 or 2.7. In libfaad
# version 2.7, the type for the samplerate is unsigned long*,
# while in 2.6 the type is uint32_t*. We can use the optional
# call parameter to CheckLibWithHeader to build a test file to
# check which one this faad.h supports.

have_faad = conf.CheckLib(['faad', 'libfaad'])
have_faad_26 = False

# Check for libfaad version 2.6. This check doesn't work correctly on Windows
# And we build it manually anyway, so we know it's v2.7
if have_faad and 'win' not in platform:
	have_faad_26 = (not conf.CheckLibWithHeader(
                        'libfaad', 'faad.h', 'c++',
                        call = 'faacDecInit2(0, 0, 0, (unsigned long*)0, (unsigned char*)0);',
                        autoadd=False))

have_m4a = have_mp4 and have_faad
flags_m4a = getFlags(env, 'm4a', 0)
if int(flags_m4a) and not have_m4a:
        if not have_mp4:
                print 'Did not find libmp4v2 or the libmp4v2 development headers, exiting!'
        if not have_faad:
                print 'Did not find libfaad or the libfaad development headers, exiting!'
        Exit(1)

#Platform-specific checks for Linux...
if platform == 'linux':
	#Check for g++ (yeah, SCONS is a bit dumb here)
	if os.system("which g++ > /dev/null"): #Checks for non-zero return code
		print "Did not find g++, exiting!"
		Exit(1)

	#Check for pkg-config
	if not conf.CheckForPKGConfig('0.15.0'):
		print 'pkg-config >= 0.15.0 not found.'
		Exit(1)

	#Check for QT >= 4.3
	if not conf.CheckForPKG('QtCore', '4.3'):
		print 'QT >= 4.3 not found.'
		Exit(1)
	else:
		#Grabs the QT4 include paths
		"""
		env.ParseConfig('pkg-config QtCore --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config Qt3Support --silence-errors --cflags') #QT3 support breaks the build
		env.ParseConfig('pkg-config QtSql --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtGui --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtXml --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtOpenGL --silence-errors --cflags --libs')
		env.ParseConfig('pkg-config QtScript --silence-errors --cflags --libs')
		"""
		#Try using David's qt4.py's Qt4-module finding thingy instead of pkg-config.
		#(This hopefully respects our qtdir=blah flag while linking now.)

		env.EnableQt4Modules([
		'QtCore',
		#'QtUiTools',
		#'QtDesigner',
		#'QtWebKit',
		],
		debug=False,
		)

#Platform-specific checks for OS X
if platform == 'osx':

	#QT4
	env.Append(LINKFLAGS = '-framework QtCore')
	env.Append(CPPPATH = ['/Library/Frameworks/QtCore.framework/Headers/'])

	#Non-standard libpaths for fink and darwin ports
	env.Append(LIBPATH = ['/sw/lib'])
	env.Append(CPPPATH = ['/sw/include'])

env = conf.Finish()

env.Append(CPPPATH = ['.', '../', '../../']) #Fun fun fun with paths
env.Append(CPPPATH = ['.', '#src', '#../src']) #Fun fun fun with paths

#declare platform specific flags? though we shouldn't really need these, the compilers should Just Know...
#on __APPLE__ it works like that. probably we just need to look into what the default __platform__ #defines are and search and replace in the code
env.Append(CPPDEFINES=machine)

if platform == 'linux':
	env.Append(CPPDEFINES='__LINUX__')
elif platform == 'bsd':
	env.Append(CPPDEFINES='__BSD__')
elif 'win' in platform:
	env.Append(CPPDEFINES='__WINDOWS__')
	env.Append(CPPDEFINES='UNICODE')	# Need this on Windows until we have UTF16 support in Mixxx
	if platform == 'win32':
		env.Append(CPPDEFINES='WIN32')
	if platform == 'win64':
		env.Append(CPPDEFINES='WIN64')

if platform in ('linux', 'bsd'): #a define for code that works on unix only can ask for (not sure if this is actually used anywhere)
	env.Append(CPPDEFINES='__UNIX__')


if platform in ('linux', 'bsd'):
	env.Append(LIBS = 'QtCore')

if 'win' in platform:
	env.Append(LIBS = 'QtCore4');

env.Append(CPPDEFINES = ['QT_THREAD_SUPPORT', 'QT_SHARED', 'QT_TABLET_SUPPORT']) #Stolen from Mixxx's build output

if platform in ('linux','bsd') or 'win' in platform:
	env.Append(CPPPATH=['$QTDIR/include/QtCore'])

if 'win' in platform:
	env.Append(CPPPATH=["$VCINSTALLDIR/include/atl", "C:/Program Files/Microsoft Platform SDK/Include/atl"])

if 'win' in platform:
	env.Append(CPPDEFINES = 'WIN32') #for soundtouch
else:
	env.Append(CCFLAGS = Split(""" -pipe -Wall -W -g """)) # omghax
	env.Append(LINKFLAGS = Split(""" -pipe -Wall -W -g"""))
	if platform != 'osx':
		env.Append(LINKFLAGS = "-Wl,-rpath,$QTDIR/lib")
	env.Append(LINKFLAGS = "-Wl,-rpath,$QTDIR/lib")
	env.Append(CPPDEFINES = "_REENTRANT")


#Tell SCons to build libraries that are bundled with Mixxx
#===================================================

## Platform-specific compile/link flags needed for fidlib
if 'win' in platform:
	env.Append(CPPDEFINES = 'T_MSVC')
	#env.Append(CXXFLAGS = '-DT_MSVC') #is this still needed?
	env.Append(LINKFLAGS = ['/nodefaultlib:LIBCMT.lib', '/nodefaultlib:LIBCMTD.lib'])
	env.Append(CXXFLAGS = '/Zc:wchar_t-') #Ugh, MSVC-only hack :( see http://www.qtforum.org/article/17883/problem-using-qstring-fromstdwstring.html
else:
	env.Append(CPPDEFINES = 'T_LINUX') #so maybe "T_LINUX" isn't really accurate for an else case, but the only platforms really in existence are Unix and Win right now, and that's all we're targetting


#Parse command-line build flags
build_flags = ""

print "\nFeatures Summary:\n================"



flags_msvcdebug = getFlags(env, 'msvcdebug', 0)
if 'win' in platform:
	if int(flags_msvcdebug):
		env.Append(CCFLAGS = '/MDd') # required for sndfile w/ flac support on windows
		env.Append(LINKFLAGS = '/DEBUG')
		if platform == 'win64':
			env.Append(CXXFLAGS = '/Zi')
			env.Append(LINKFLAGS = '/NODEFAULTLIB:MSVCRT')
		else:
			env.Append(CXXFLAGS = '/ZI')
		print "MSVC Debugging... enabled"
		build_flags += 'msvcdebug '
	else:
		env.Append(LINKFLAGS = '/subsystem:windows')
		env.Append(CCFLAGS = '/MD') # required for sndfile w/ flac support on windows
		print "MSVC Debugging... disabled"


flags_m4a = getFlags(env, 'm4a', 0)
if int(flags_m4a):
	print "Apple M4A audio file support...",
	if have_m4a:
		print "enabled"

		# If the compile did not work, then enable the M4AHACK define.
		if have_faad_26:
			env.Append(CPPDEFINES = '__M4AHACK__')
			print "libfaad 2.6 compatibility mode... enabled"

		if have_mp4v2_h:
			env.Append(CPPDEFINES = '__MP4V2__')

	#	env.ParseConfig('pkg-config libmp4v2-dev --silence-errors --cflags --libs') # no pkg-config data for libmp4v2-dev
	#	FIXME: should do conf.CheckCHeader('mp4.h') or something...
		env.Append(CPPDEFINES = '__M4A__')
		build_flags += 'm4a '
		sources += Split("""soundsourcem4a.cpp""");  # MP4/M4A Support
		env.Append(LIBS = 'libmp4v2')
		env.Append(LIBS = 'libfaad')
	else:
		print "not found (did you install libmp4v2 and libfaad?)"
else:
	print "Apple M4A audio file support... disabled"

# Profiling and Optimization
if not 'win' in platform:
	flags_gprof = getFlags(env, 'gprof', 0)
	if int(flags_gprof):
		env.Append(CCFLAGS = '-pg')
		env.Append(LINKFLAGS = '-pg')
		print "gprof profiling support... enabled"
		build_flags += 'gprof '
	else:
		print "gprof profiling support... disabled"

flags_tuned = getFlags(env, 'tuned', 0)
if int(flags_tuned):
	if not 'win' in platform:
		ccv = env['CCVERSION'].split('.')
		if int(ccv[0]) >= 4 and int(ccv[1]) >= 2:
			env.Append(CCFLAGS = '-march=native')
			env.Append(LINKFLAGS = '-march=native')
			print "Optimizing for this CPU... yes"
			build_flags += 'tuned '
		else:
			print "Optimizing for this CPU... no (requires gcc >= 4.2.0)"
	else:
		if platform == 'win64':
			print "Optimizing for this CPU class (" + machine + ")... yes"
			env.Append(CXXFLAGS = '/favor:' + machine)
		else:
			print "Optimizing for this CPU... no (not supported on 32-bit MSVC)"
else:
	if platform == 'win64':
		if 'makerelease' in COMMAND_LINE_TARGETS:
			print "Optimizing for this CPU class... no\n  (using AMD64 due to makerelease)"
			# AMD64 architecture is used by all consumer 64-bit CPUs, even Intel ones.
			# IA64 is the Itanium processors, which we don't expect anyone to be using for DJing. :)
			env.Append(CXXFLAGS = '/favor:AMD64')

#Specific optimization
flags_optimize = getFlags(env, 'optimize', 1)
if int(flags_optimize):
	if 'win' in platform:
		if platform == 'win64':
			env.Append(LINKFLAGS = '/MACHINE:X64')
		else:
			env.Append(LINKFLAGS = '/MACHINE:X86')
		if int(flags_msvcdebug):
			print "Specific optimizations... DISABLED DUE TO DEBUG"
		else:
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags_optimize) + ' '
			env.Append(CXXFLAGS = '/GL /MP')
			env.Append(LINKFLAGS = '/LTCG:STATUS')
			if flags_optimize=='1':
				print "  Maximize speed (/O2)"
				env.Append(CXXFLAGS = '/O2')
			elif flags_optimize >= '2':
				print "  Maximum optimizations (/Ox)"
				env.Append(CXXFLAGS = '/Ox')
			if not platform == 'win64':
				if flags_optimize == '3':
					print "  SSE instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE')
				elif flags_optimize == '4':
					print "  SSE2 instructions enabled"
					env.Append(CXXFLAGS = '/arch:SSE2')
	else:
		if not int(flags_tuned):
			print "Specific optimizations... enabled"
			build_flags += 'optimize=' + str(flags_optimize) + ' '
			env.Replace(CFLAGS = '') # replace CFLAGS and CXXFLAGS with our own optimizations.
			if flags_optimize=='1':
				env.Replace(CXXFLAGS = '-O3')
			elif flags_optimize=='2':
				print "  P4 MMX/SSE optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=pentium4 -mmmx -msse2 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags_optimize=='3':
				print "  Intel Core Solo/Duo optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=prescott -mmmx -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags_optimize=='4':
				print "  Intel Core 2 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=nocona -mmmx -msse3 -mfpmath=sse -ffast-math -funroll-loops')
			elif flags_optimize=='5':
				print "  Athlon Athlon-4/XP/MP optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=athlon-4 -mmmx -msse -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags_optimize=='6':
				print "  Athlon K8/Opteron/AMD64 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8 -mmmx -msse2 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags_optimize=='7':
				print "  Athlon K8/Opteron/AMD64 + SSE3 optimizations enabled."
				env.Replace(CXXFLAGS = '-O3 -march=k8-sse3 -mmmx -msse2 -msse3 -m3dnow -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			elif flags_optimize=='8':
				print "  Generic SSE/SSE2/SSE3 optimizations enabled (Celeron D)."
				env.Replace(CXXFLAGS = '-O3 -mmmx -msse2 -msse3 -mfpmath=sse -fomit-frame-pointer -ffast-math -funroll-loops')
			env.Append(CXXFLAGS = ' ') # add a space to the end of CXXFLAGS
else:
	print "Specific optimizations... disabled"

#Debugging output
flags_qdebug = getFlags(env, 'qdebug', 0)
if 'win' in platform:
	if int(flags_msvcdebug):
		flags_qdebug = 1		# Turn general debugging flag on too if msvcdebug is specified

if int(flags_qdebug):
	build_flags += 'qdebug '
	print "Debugging message output... enabled"
else:
	env.Append(CPPDEFINES = 'QT_NO_DEBUG_OUTPUT')
	print "Debugging message output... disabled"

#Visual Studio 2005 hacks (MSVS Express Edition users shouldn't enable this)
flags_msvshacks = getFlags(env, 'msvshacks', 0)
if int(flags_msvshacks):
	env.Append(CPPDEFINES = '__MSVS2005__')
	print "MSVS 2005 hacks... enabled"
	build_flags += 'msvshacks '
else:
	print "MSVS 2005 hacks... disabled"

#force 32-bit compile on GCC
flags_force32 = getFlags(env, 'force32', 0)
if int(flags_force32):
	env.Append(CCFLAGS = '-m32')
	env.Append(CXXFLAGS = '-m32')
	print "Force 32-bit GCC compile... enabled"
else:
	print "Force 32-bit GCC compile... disabled"

### Put flags info into a file
f = open("build.h","a")
try:
	f.write('#define BUILD_FLAGS "' + build_flags + '"\n')
finally:
	f.close()

# Print the build flags (useful if the flags have been cached, ie. if you just run "scons"
# and want to see the flags that you used last time)
print "================"
print "Building with flags: " + build_flags
print "================\n"

#Save the options to cache
vars.Save(cachefile, env)

#Tell SCons to build the SoundSourceM4A plugin
#=========================
SHLIBPREFIX='lib' #Makes the filename "libsoundsourcem4a" consistently across platforms to make our lives easier.
if 'win' in platform:
	ssm4a_bin = env.SharedLibrary('soundsourcem4a', sources, LINKCOM  = [env['LINKCOM'], 'mt.exe -nologo -manifest ${TARGET}.manifest -outputresource:$TARGET;1'])
else:
	ssm4a_bin = env.SharedLibrary('soundsourcem4a', sources)

#Pass this soundsourcem4a library object file back to the SConscript above us.
if int(flags_m4a):
	Return("ssm4a_bin")
else
    Return("")

"""
if platform in ('linux', 'bsd'):
	flags_prefix = ARGUMENTS.get('prefix', '/usr/local')
	if not os.path.exists(flags_prefix):
		print "Error: Prefix path does not exist!"
		Exit(1)
	else:
		#install_root is used in Debian/Ubuntu packaging (check the debian/rules file in the Ubuntu package)
		#Basically, the flags_prefix is compiled into strings in Mixxx, whereas the install_root is not. When you're
		#building a Debian package, pbuilder wants to install Mixxx to a temporary directory, but you still need
		#the compiled-in strings using /usr as the prefix. That's why we have install_root and flags_prefix.
		install_root = ARGUMENTS.get('install_root', flags_prefix)
		print "Install root: " + install_root
		if install_root != flags_prefix:
			unix_lib_path = install_root + "/share"
		else:
			unix_lib_path = flags_prefix + "/share"

		plugin = env.Install(unix_lib_path + "/mixxx", plugin_files)

		#Fire off this install builder when you run "scons install"
		env.Alias('install', plugin)
"""

